{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { VSN, CHANNEL_EVENTS, TRANSPORTS, SOCKET_STATES, DEFAULT_TIMEOUT, WS_CLOSE_NORMAL, DEFAULT_HEADERS } from './lib/constants';\nimport Timer from './lib/timer';\nimport RealtimeSubscription from './RealtimeSubscription';\nimport { w3cwebsocket as WebSocket } from 'websocket';\nimport Serializer from './lib/serializer';\n\nvar noop = function noop() {};\n\nvar RealtimeClient = /*#__PURE__*/function () {\n  /**\n   * Initializes the Socket\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  function RealtimeClient(endPoint, options) {\n    var _this = this;\n\n    _classCallCheck(this, RealtimeClient);\n\n    this.accessToken = null;\n    this.channels = [];\n    this.endPoint = '';\n    this.headers = DEFAULT_HEADERS;\n    this.params = {};\n    this.timeout = DEFAULT_TIMEOUT;\n    this.transport = WebSocket;\n    this.heartbeatIntervalMs = 30000;\n    this.longpollerTimeout = 20000;\n    this.heartbeatTimer = undefined;\n    this.pendingHeartbeatRef = null;\n    this.ref = 0;\n    this.logger = noop;\n    this.conn = null;\n    this.sendBuffer = [];\n    this.serializer = new Serializer();\n    this.stateChangeCallbacks = {\n      open: [],\n      close: [],\n      error: [],\n      message: []\n    };\n    this.endPoint = \"\".concat(endPoint, \"/\").concat(TRANSPORTS.websocket);\n    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);\n    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;\n    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n    if (options === null || options === void 0 ? void 0 : options.transport) this.transport = options.transport;\n    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;\n    if (options === null || options === void 0 ? void 0 : options.longpollerTimeout) this.longpollerTimeout = options.longpollerTimeout;\n    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : function (tries) {\n      return [1000, 2000, 5000, 10000][tries - 1] || 10000;\n    };\n    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : function (payload, callback) {\n      return callback(JSON.stringify(payload));\n    };\n    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);\n    this.reconnectTimer = new Timer(function () {\n      return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.disconnect();\n\n              case 2:\n                this.connect();\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }, this.reconnectAfterMs);\n  }\n  /**\n   * Connects the socket.\n   */\n\n\n  _createClass(RealtimeClient, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      if (this.conn) {\n        return;\n      }\n\n      this.conn = new this.transport(this.endPointURL(), [], null, this.headers);\n\n      if (this.conn) {\n        // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n        this.conn.binaryType = 'arraybuffer';\n\n        this.conn.onopen = function () {\n          return _this2._onConnOpen();\n        };\n\n        this.conn.onerror = function (error) {\n          return _this2._onConnError(error);\n        };\n\n        this.conn.onmessage = function (event) {\n          return _this2.onConnMessage(event);\n        };\n\n        this.conn.onclose = function (event) {\n          return _this2._onConnClose(event);\n        };\n      }\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(code, reason) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, _reject) {\n        try {\n          if (_this3.conn) {\n            _this3.conn.onclose = function () {}; // noop\n\n\n            if (code) {\n              _this3.conn.close(code, reason || '');\n            } else {\n              _this3.conn.close();\n            }\n\n            _this3.conn = null; // remove open handles\n\n            _this3.heartbeatTimer && clearInterval(_this3.heartbeatTimer);\n\n            _this3.reconnectTimer.reset();\n          }\n\n          resolve({\n            error: null,\n            data: true\n          });\n        } catch (error) {\n          resolve({\n            error: error,\n            data: false\n          });\n        }\n      });\n    }\n    /**\n     * Logs the message. Override `this.logger` for specialized logging.\n     */\n\n  }, {\n    key: \"log\",\n    value: function log(kind, msg, data) {\n      this.logger(kind, msg, data);\n    }\n    /**\n     * Registers a callback for connection state change event.\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket opened.\"))\n     */\n\n  }, {\n    key: \"onOpen\",\n    value: function onOpen(callback) {\n      this.stateChangeCallbacks.open.push(callback);\n    }\n    /**\n     * Registers a callbacks for connection state change events.\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen(() => console.log(\"Socket closed.\"))\n     */\n\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.stateChangeCallbacks.close.push(callback);\n    }\n    /**\n     * Registers a callback for connection state change events.\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onOpen((error) => console.log(\"An error occurred\"))\n     */\n\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.stateChangeCallbacks.error.push(callback);\n    }\n    /**\n     * Calls a function any time a message is received.\n     * @param callback A function to be called when the event occurs.\n     *\n     * @example\n     *    socket.onMessage((message) => console.log(message))\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(callback) {\n      this.stateChangeCallbacks.message.push(callback);\n    }\n    /**\n     * Returns the current state of the socket.\n     */\n\n  }, {\n    key: \"connectionState\",\n    value: function connectionState() {\n      switch (this.conn && this.conn.readyState) {\n        case SOCKET_STATES.connecting:\n          return 'connecting';\n\n        case SOCKET_STATES.open:\n          return 'open';\n\n        case SOCKET_STATES.closing:\n          return 'closing';\n\n        default:\n          return 'closed';\n      }\n    }\n    /**\n     * Retuns `true` is the connection is open.\n     */\n\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.connectionState() === 'open';\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(channel) {\n      this.channels = this.channels.filter(function (c) {\n        return c.joinRef() !== channel.joinRef();\n      });\n    }\n  }, {\n    key: \"channel\",\n    value: function channel(topic) {\n      var chanParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var chan = new RealtimeSubscription(topic, chanParams, this);\n      this.channels.push(chan);\n      return chan;\n    }\n  }, {\n    key: \"push\",\n    value: function push(data) {\n      var _this4 = this;\n\n      var topic = data.topic,\n          event = data.event,\n          payload = data.payload,\n          ref = data.ref;\n\n      var callback = function callback() {\n        _this4.encode(data, function (result) {\n          var _a;\n\n          (_a = _this4.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n        });\n      };\n\n      this.log('push', \"\".concat(topic, \" \").concat(event, \" (\").concat(ref, \")\"), payload);\n\n      if (this.isConnected()) {\n        callback();\n      } else {\n        this.sendBuffer.push(callback);\n      }\n    }\n  }, {\n    key: \"onConnMessage\",\n    value: function onConnMessage(rawMessage) {\n      var _this5 = this;\n\n      this.decode(rawMessage.data, function (msg) {\n        var topic = msg.topic,\n            event = msg.event,\n            payload = msg.payload,\n            ref = msg.ref;\n\n        if (ref && ref === _this5.pendingHeartbeatRef) {\n          _this5.pendingHeartbeatRef = null;\n        } else if (event === (payload === null || payload === void 0 ? void 0 : payload.type)) {\n          _this5._resetHeartbeat();\n        }\n\n        _this5.log('receive', \"\".concat(payload.status || '', \" \").concat(topic, \" \").concat(event, \" \").concat(ref && '(' + ref + ')' || ''), payload);\n\n        _this5.channels.filter(function (channel) {\n          return channel.isMember(topic);\n        }).forEach(function (channel) {\n          return channel.trigger(event, payload, ref);\n        });\n\n        _this5.stateChangeCallbacks.message.forEach(function (callback) {\n          return callback(msg);\n        });\n      });\n    }\n    /**\n     * Returns the URL of the websocket.\n     */\n\n  }, {\n    key: \"endPointURL\",\n    value: function endPointURL() {\n      return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n        vsn: VSN\n      }));\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     */\n\n  }, {\n    key: \"makeRef\",\n    value: function makeRef() {\n      var newRef = this.ref + 1;\n\n      if (newRef === this.ref) {\n        this.ref = 0;\n      } else {\n        this.ref = newRef;\n      }\n\n      return this.ref.toString();\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * @param token A JWT string.\n     */\n\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(token) {\n      this.accessToken = token;\n\n      try {\n        this.channels.forEach(function (channel) {\n          token && channel.updateJoinPayload({\n            user_token: token\n          });\n\n          if (channel.joinedOnce && channel.isJoined()) {\n            channel.push(CHANNEL_EVENTS.access_token, {\n              access_token: token\n            });\n          }\n        });\n      } catch (error) {\n        console.log('setAuth error', error);\n      }\n    }\n  }, {\n    key: \"_onConnOpen\",\n    value: function _onConnOpen() {\n      this.log('transport', \"connected to \".concat(this.endPointURL()));\n\n      this._flushSendBuffer();\n\n      this.reconnectTimer.reset();\n\n      this._resetHeartbeat();\n\n      this.stateChangeCallbacks.open.forEach(function (callback) {\n        return callback();\n      });\n    }\n  }, {\n    key: \"_onConnClose\",\n    value: function _onConnClose(event) {\n      this.log('transport', 'close', event);\n\n      this._triggerChanError();\n\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.reconnectTimer.scheduleTimeout();\n      this.stateChangeCallbacks.close.forEach(function (callback) {\n        return callback(event);\n      });\n    }\n  }, {\n    key: \"_onConnError\",\n    value: function _onConnError(error) {\n      this.log('transport', error.message);\n\n      this._triggerChanError();\n\n      this.stateChangeCallbacks.error.forEach(function (callback) {\n        return callback(error);\n      });\n    }\n  }, {\n    key: \"_triggerChanError\",\n    value: function _triggerChanError() {\n      this.channels.forEach(function (channel) {\n        return channel.trigger(CHANNEL_EVENTS.error);\n      });\n    }\n  }, {\n    key: \"_appendParams\",\n    value: function _appendParams(url, params) {\n      if (Object.keys(params).length === 0) {\n        return url;\n      }\n\n      var prefix = url.match(/\\?/) ? '&' : '?';\n      var query = new URLSearchParams(params);\n      return \"\".concat(url).concat(prefix).concat(query);\n    }\n  }, {\n    key: \"_flushSendBuffer\",\n    value: function _flushSendBuffer() {\n      if (this.isConnected() && this.sendBuffer.length > 0) {\n        this.sendBuffer.forEach(function (callback) {\n          return callback();\n        });\n        this.sendBuffer = [];\n      }\n    }\n  }, {\n    key: \"_resetHeartbeat\",\n    value: function _resetHeartbeat() {\n      var _this6 = this;\n\n      this.pendingHeartbeatRef = null;\n      this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n      this.heartbeatTimer = setInterval(function () {\n        return _this6._sendHeartbeat();\n      }, this.heartbeatIntervalMs);\n    }\n  }, {\n    key: \"_sendHeartbeat\",\n    value: function _sendHeartbeat() {\n      var _a;\n\n      if (!this.isConnected()) {\n        return;\n      }\n\n      if (this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null;\n        this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');\n        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(WS_CLOSE_NORMAL, 'hearbeat timeout');\n        return;\n      }\n\n      this.pendingHeartbeatRef = this.makeRef();\n      this.push({\n        topic: 'phoenix',\n        event: 'heartbeat',\n        payload: {},\n        ref: this.pendingHeartbeatRef\n      });\n      this.setAuth(this.accessToken);\n    }\n  }]);\n\n  return RealtimeClient;\n}();\n\nexport { RealtimeClient as default };","map":{"version":3,"sources":["C:\\Users\\Dave\\WebstormProjects\\wappsite\\node_modules\\@supabase\\realtime-js\\src\\RealtimeClient.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  VSN,\n  CHANNEL_EVENTS,\n  TRANSPORTS,\n  SOCKET_STATES,\n  DEFAULT_TIMEOUT,\n  WS_CLOSE_NORMAL,\n  DEFAULT_HEADERS,\n} from './lib/constants'\nimport Timer from './lib/timer'\nimport RealtimeSubscription from './RealtimeSubscription'\nimport { w3cwebsocket as WebSocket } from 'websocket'\nimport Serializer from './lib/serializer'\n\nexport type Options = {\n  transport?: WebSocket\n  timeout?: number\n  heartbeatIntervalMs?: number\n  longpollerTimeout?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: string }\n}\ntype Message = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n}\n\nconst noop = () => {}\n\nexport default class RealtimeClient {\n  accessToken: string | null = null\n  channels: RealtimeSubscription[] = []\n  endPoint: string = ''\n  headers?: { [key: string]: string } = DEFAULT_HEADERS\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: any = WebSocket\n  heartbeatIntervalMs: number = 30000\n  longpollerTimeout: number = 20000\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  ref: number = 0\n  reconnectTimer: Timer\n  logger: Function = noop\n  encode: Function\n  decode: Function\n  reconnectAfterMs: Function\n  conn: WebSocket | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n\n  /**\n   * Initializes the Socket\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket.\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers The optional headers to pass when connecting.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.longpollerTimeout The maximum timeout of a long poll AJAX request. Defaults to 20s (double the server long poll timer).\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   */\n  constructor(endPoint: string, options?: Options) {\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n\n    if (options?.params) this.params = options.params\n    if (options?.headers) this.headers = { ...this.headers, ...options.headers }\n    if (options?.timeout) this.timeout = options.timeout\n    if (options?.logger) this.logger = options.logger\n    if (options?.transport) this.transport = options.transport\n    if (options?.heartbeatIntervalMs)\n      this.heartbeatIntervalMs = options.heartbeatIntervalMs\n    if (options?.longpollerTimeout)\n      this.longpollerTimeout = options.longpollerTimeout\n\n    this.reconnectAfterMs = options?.reconnectAfterMs\n      ? options.reconnectAfterMs\n      : (tries: number) => {\n          return [1000, 2000, 5000, 10000][tries - 1] || 10000\n        }\n    this.encode = options?.encode\n      ? options.encode\n      : (payload: JSON, callback: Function) => {\n          return callback(JSON.stringify(payload))\n        }\n    this.decode = options?.decode\n      ? options.decode\n      : this.serializer.decode.bind(this.serializer)\n    this.reconnectTimer = new Timer(async () => {\n      await this.disconnect()\n      this.connect()\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Connects the socket.\n   */\n  connect() {\n    if (this.conn) {\n      return\n    }\n\n    this.conn = new this.transport(this.endPointURL(), [], null, this.headers)\n    if (this.conn) {\n      // this.conn.timeout = this.longpollerTimeout // TYPE ERROR\n      this.conn.binaryType = 'arraybuffer'\n      this.conn.onopen = () => this._onConnOpen()\n      this.conn.onerror = (error) => this._onConnError(error)\n      this.conn.onmessage = (event) => this.onConnMessage(event)\n      this.conn.onclose = (event) => this._onConnClose(event)\n    }\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(\n    code?: number,\n    reason?: string\n  ): Promise<{ error: Error | null; data: boolean }> {\n    return new Promise((resolve, _reject) => {\n      try {\n        if (this.conn) {\n          this.conn.onclose = function () {} // noop\n          if (code) {\n            this.conn.close(code, reason || '')\n          } else {\n            this.conn.close()\n          }\n          this.conn = null\n          // remove open handles\n          this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n          this.reconnectTimer.reset()\n        }\n        resolve({ error: null, data: true })\n      } catch (error) {\n        resolve({ error: error as Error, data: false })\n      }\n    })\n  }\n\n  /**\n   * Logs the message. Override `this.logger` for specialized logging.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Registers a callback for connection state change event.\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket opened.\"))\n   */\n  onOpen(callback: Function) {\n    this.stateChangeCallbacks.open.push(callback)\n  }\n\n  /**\n   * Registers a callbacks for connection state change events.\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen(() => console.log(\"Socket closed.\"))\n   */\n  onClose(callback: Function) {\n    this.stateChangeCallbacks.close.push(callback)\n  }\n\n  /**\n   * Registers a callback for connection state change events.\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onOpen((error) => console.log(\"An error occurred\"))\n   */\n  onError(callback: Function) {\n    this.stateChangeCallbacks.error.push(callback)\n  }\n\n  /**\n   * Calls a function any time a message is received.\n   * @param callback A function to be called when the event occurs.\n   *\n   * @example\n   *    socket.onMessage((message) => console.log(message))\n   */\n  onMessage(callback: Function) {\n    this.stateChangeCallbacks.message.push(callback)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState() {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return 'connecting'\n      case SOCKET_STATES.open:\n        return 'open'\n      case SOCKET_STATES.closing:\n        return 'closing'\n      default:\n        return 'closed'\n    }\n  }\n\n  /**\n   * Retuns `true` is the connection is open.\n   */\n  isConnected() {\n    return this.connectionState() === 'open'\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   */\n  remove(channel: RealtimeSubscription) {\n    this.channels = this.channels.filter(\n      (c: RealtimeSubscription) => c.joinRef() !== channel.joinRef()\n    )\n  }\n\n  channel(topic: string, chanParams = {}) {\n    let chan = new RealtimeSubscription(topic, chanParams, this)\n    this.channels.push(chan)\n    return chan\n  }\n\n  push(data: Message) {\n    let { topic, event, payload, ref } = data\n    let callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  onConnMessage(rawMessage: any) {\n    this.decode(rawMessage.data, (msg: Message) => {\n      let { topic, event, payload, ref } = msg\n      if (ref && ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null\n      } else if (event === payload?.type) {\n        this._resetHeartbeat()\n      }\n\n      this.log(\n        'receive',\n        `${payload.status || ''} ${topic} ${event} ${\n          (ref && '(' + ref + ')') || ''\n        }`,\n        payload\n      )\n      this.channels\n        .filter((channel: RealtimeSubscription) => channel.isMember(topic))\n        .forEach((channel: RealtimeSubscription) =>\n          channel.trigger(event, payload, ref)\n        )\n      this.stateChangeCallbacks.message.forEach((callback) => callback(msg))\n    })\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   */\n  endPointURL() {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   */\n  makeRef() {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * @param token A JWT string.\n   */\n  setAuth(token: string | null) {\n    this.accessToken = token\n\n    try {\n      this.channels.forEach((channel) => {\n        token && channel.updateJoinPayload({ user_token: token })\n\n        if (channel.joinedOnce && channel.isJoined()) {\n          channel.push(CHANNEL_EVENTS.access_token, { access_token: token })\n        }\n      })\n    } catch (error) {\n      console.log('setAuth error', error)\n    }\n  }\n\n  private _onConnOpen() {\n    this.log('transport', `connected to ${this.endPointURL()}`)\n    this._flushSendBuffer()\n    this.reconnectTimer.reset()\n    this._resetHeartbeat()\n    this.stateChangeCallbacks.open.forEach((callback) => callback())!\n  }\n\n  private _onConnClose(event: any) {\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.reconnectTimer.scheduleTimeout()\n    this.stateChangeCallbacks.close.forEach((callback) => callback(event))\n  }\n\n  private _onConnError(error: Error) {\n    this.log('transport', error.message)\n    this._triggerChanError()\n    this.stateChangeCallbacks.error.forEach((callback) => callback(error))\n  }\n\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeSubscription) =>\n      channel.trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  private _appendParams(url: string, params: { [key: string]: string }) {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n\n    return `${url}${prefix}${query}`\n  }\n\n  private _flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  private _resetHeartbeat() {\n    this.pendingHeartbeatRef = null\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this._sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n  }\n\n  private _sendHeartbeat() {\n    if (!this.isConnected()) {\n      return\n    }\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.conn?.close(WS_CLOSE_NORMAL, 'hearbeat timeout')\n      return\n    }\n    this.pendingHeartbeatRef = this.makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.setAuth(this.accessToken)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}