{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport crossFetch from 'cross-fetch';\nexport var PostgrestBuilder = /*#__PURE__*/function () {\n  function PostgrestBuilder(builder) {\n    _classCallCheck(this, PostgrestBuilder);\n\n    this.shouldThrowOnError = false;\n    Object.assign(this, builder);\n    this.fetch = builder.fetch || crossFetch;\n  }\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n\n\n  _createClass(PostgrestBuilder, [{\n    key: \"throwOnError\",\n    value: function throwOnError() {\n      this.shouldThrowOnError = true;\n      return this;\n    }\n  }, {\n    key: \"then\",\n    value: function then(onfulfilled, onrejected) {\n      var _this = this;\n\n      // https://postgrest.org/en/stable/api.html#switching-schemas\n      if (typeof this.schema === 'undefined') {// skip\n      } else if (['GET', 'HEAD'].includes(this.method)) {\n        this.headers['Accept-Profile'] = this.schema;\n      } else {\n        this.headers['Content-Profile'] = this.schema;\n      }\n\n      if (this.method !== 'GET' && this.method !== 'HEAD') {\n        this.headers['Content-Type'] = 'application/json';\n      }\n\n      var res = this.fetch(this.url.toString(), {\n        method: this.method,\n        headers: this.headers,\n        body: JSON.stringify(this.body),\n        signal: this.signal\n      }).then(function (res) {\n        return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var _a, _b, _c, error, data, count, isReturnMinimal, text, countHeader, contentRange, body, postgrestResponse;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  error = null;\n                  data = null;\n                  count = null;\n\n                  if (!res.ok) {\n                    _context.next = 15;\n                    break;\n                  }\n\n                  isReturnMinimal = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.split(',').includes('return=minimal');\n\n                  if (!(this.method !== 'HEAD' && !isReturnMinimal)) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  _context.next = 8;\n                  return res.text();\n\n                case 8:\n                  text = _context.sent;\n\n                  if (!text) {// discard `text`\n                  } else if (this.headers['Accept'] === 'text/csv') {\n                    data = text;\n                  } else {\n                    data = JSON.parse(text);\n                  }\n\n                case 10:\n                  countHeader = (_b = this.headers['Prefer']) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n                  contentRange = (_c = res.headers.get('content-range')) === null || _c === void 0 ? void 0 : _c.split('/');\n\n                  if (countHeader && contentRange && contentRange.length > 1) {\n                    count = parseInt(contentRange[1]);\n                  }\n\n                  _context.next = 21;\n                  break;\n\n                case 15:\n                  _context.next = 17;\n                  return res.text();\n\n                case 17:\n                  body = _context.sent;\n\n                  try {\n                    error = JSON.parse(body);\n                  } catch (_d) {\n                    error = {\n                      message: body\n                    };\n                  }\n\n                  if (!(error && this.shouldThrowOnError)) {\n                    _context.next = 21;\n                    break;\n                  }\n\n                  throw error;\n\n                case 21:\n                  postgrestResponse = {\n                    error: error,\n                    data: data,\n                    count: count,\n                    status: res.status,\n                    statusText: res.statusText,\n                    body: data\n                  };\n                  return _context.abrupt(\"return\", postgrestResponse);\n\n                case 23:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n      });\n\n      if (!this.shouldThrowOnError) {\n        res = res.catch(function (fetchError) {\n          return {\n            error: {\n              message: \"FetchError: \".concat(fetchError.message),\n              details: '',\n              hint: '',\n              code: fetchError.code || ''\n            },\n            data: null,\n            body: null,\n            count: null,\n            status: 400,\n            statusText: 'Bad Request'\n          };\n        });\n      }\n\n      return res.then(onfulfilled, onrejected);\n    }\n  }]);\n\n  return PostgrestBuilder;\n}();","map":{"version":3,"sources":["C:\\Users\\Dave\\WebstormProjects\\wappsite\\node_modules\\@supabase\\postgrest-js\\src\\lib\\types.ts"],"names":[],"mappings":"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","sourcesContent":["import crossFetch from 'cross-fetch'\n\nexport type Fetch = typeof fetch\n\n/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport type PostgrestError = {\n  message: string\n  details: string\n  hint: string\n  code: string\n}\n\n/**\n * Response format\n *\n * {@link https://github.com/supabase/supabase-js/issues/32}\n */\ninterface PostgrestResponseBase {\n  status: number\n  statusText: string\n}\n\ninterface PostgrestResponseSuccess<T> extends PostgrestResponseBase {\n  error: null\n  data: T[]\n  body: T[]\n  count: number | null\n}\ninterface PostgrestResponseFailure extends PostgrestResponseBase {\n  error: PostgrestError\n  data: null\n  // For backward compatibility: body === data\n  body: null\n  count: null\n}\nexport type PostgrestResponse<T> = PostgrestResponseSuccess<T> | PostgrestResponseFailure\n\ninterface PostgrestSingleResponseSuccess<T> extends PostgrestResponseBase {\n  error: null\n  data: T\n  // For backward compatibility: body === data\n  body: T\n}\nexport type PostgrestSingleResponse<T> =\n  | PostgrestSingleResponseSuccess<T>\n  | PostgrestResponseFailure\nexport type PostgrestMaybeSingleResponse<T> = PostgrestSingleResponse<T | null>\n\nexport abstract class PostgrestBuilder<T> implements PromiseLike<PostgrestResponse<T>> {\n  protected method!: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url!: URL\n  protected headers!: { [key: string]: string }\n  protected schema?: string\n  protected body?: Partial<T> | Partial<T>[]\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n\n  constructor(builder: PostgrestBuilder<T>) {\n    Object.assign(this, builder)\n    this.fetch = builder.fetch || crossFetch\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): PostgrestBuilder<T> {\n    this.shouldThrowOnError = true\n    return this\n  }\n\n  then<TResult1 = PostgrestResponse<T>, TResult2 = never>(\n    onfulfilled?:\n      | ((value: PostgrestResponse<T>) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (typeof this.schema === 'undefined') {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers['Accept-Profile'] = this.schema\n    } else {\n      this.headers['Content-Profile'] = this.schema\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers['Content-Type'] = 'application/json'\n    }\n\n    let res = this.fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count = null\n\n      if (res.ok) {\n        const isReturnMinimal = this.headers['Prefer']?.split(',').includes('return=minimal')\n        if (this.method !== 'HEAD' && !isReturnMinimal) {\n          const text = await res.text()\n          if (!text) {\n            // discard `text`\n          } else if (this.headers['Accept'] === 'text/csv') {\n            data = text\n          } else {\n            data = JSON.parse(text)\n          }\n        }\n\n        const countHeader = this.headers['Prefer']?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n        } catch {\n          error = {\n            message: body,\n          }\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw error\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status: res.status,\n        statusText: res.statusText,\n        body: data,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => ({\n        error: {\n          message: `FetchError: ${fetchError.message}`,\n          details: '',\n          hint: '',\n          code: fetchError.code || '',\n        },\n        data: null,\n        body: null,\n        count: null,\n        status: 400,\n        statusText: 'Bad Request',\n      }))\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}