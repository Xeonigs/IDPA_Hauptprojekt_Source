{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { stripTrailingSlash, isBrowser } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder';\nimport { SupabaseStorageClient } from '@supabase/storage-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient } from '@supabase/realtime-js';\nvar DEFAULT_OPTIONS = {\n  schema: 'public',\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\n\nvar SupabaseClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.headers Any additional headers to send with each network request.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.fetch A custom fetch implementation.\n   */\n  function SupabaseClient(supabaseUrl, supabaseKey, options) {\n    _classCallCheck(this, SupabaseClient);\n\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.');\n    if (!supabaseKey) throw new Error('supabaseKey is required.');\n    supabaseUrl = stripTrailingSlash(supabaseUrl);\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.restUrl = \"\".concat(supabaseUrl, \"/rest/v1\");\n    this.realtimeUrl = \"\".concat(supabaseUrl, \"/realtime/v1\").replace('http', 'ws');\n    this.authUrl = \"\".concat(supabaseUrl, \"/auth/v1\");\n    this.storageUrl = \"\".concat(supabaseUrl, \"/storage/v1\");\n    this.schema = settings.schema;\n    this.multiTab = settings.multiTab;\n    this.fetch = settings.fetch;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), options === null || options === void 0 ? void 0 : options.headers);\n    this.auth = this._initSupabaseAuthClient(settings);\n    this.realtime = this._initRealtimeClient(Object.assign({\n      headers: this.headers\n    }, settings.realtime));\n\n    this._listenForAuthEvents();\n\n    this._listenForMultiTabEvents(); // In the future we might allow the user to pass in a logger to receive these events.\n    // this.realtime.onOpen(() => console.log('OPEN'))\n    // this.realtime.onClose(() => console.log('CLOSED'))\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\n\n  }\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n\n\n  _createClass(SupabaseClient, [{\n    key: \"storage\",\n    get: function get() {\n      return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch);\n    }\n    /**\n     * Perform a table operation.\n     *\n     * @param table The table name to operate on.\n     */\n\n  }, {\n    key: \"from\",\n    value: function from(table) {\n      var url = \"\".concat(this.restUrl, \"/\").concat(table);\n      return new SupabaseQueryBuilder(url, {\n        headers: this._getAuthHeaders(),\n        schema: this.schema,\n        realtime: this.realtime,\n        table: table,\n        fetch: this.fetch\n      });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn  The function name to call.\n     * @param params  The parameters to pass to the function call.\n     * @param head   When set to true, no data will be returned.\n     * @param count  Count algorithm to use to count rows in a table.\n     *\n     */\n\n  }, {\n    key: \"rpc\",\n    value: function rpc(fn, params) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          _ref$head = _ref.head,\n          head = _ref$head === void 0 ? false : _ref$head,\n          _ref$count = _ref.count,\n          count = _ref$count === void 0 ? null : _ref$count;\n\n      var rest = this._initPostgRESTClient();\n\n      return rest.rpc(fn, params, {\n        head: head,\n        count: count\n      });\n    }\n    /**\n     * Remove all subscriptions.\n     */\n\n  }, {\n    key: \"removeAllSubscriptions\",\n    value: function removeAllSubscriptions() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var subscriptions;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                subscriptions = this.realtime.channels.slice();\n                _context.next = 3;\n                return Promise.allSettled(subscriptions.map(function (sub) {\n                  return _this.removeSubscription(sub);\n                }));\n\n              case 3:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Removes an active subscription and returns the number of open connections.\n     *\n     * @param subscription The subscription you want to remove.\n     */\n\n  }, {\n    key: \"removeSubscription\",\n    value: function removeSubscription(subscription) {\n      var _this2 = this;\n\n      return new Promise(function (resolve) {\n        return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var allSubscriptions, openSubscriptionsCount, _yield$this$realtime$, error;\n\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.prev = 0;\n                  _context2.next = 3;\n                  return this._closeSubscription(subscription);\n\n                case 3:\n                  allSubscriptions = this.getSubscriptions();\n                  openSubscriptionsCount = allSubscriptions.filter(function (chan) {\n                    return chan.isJoined();\n                  }).length;\n\n                  if (allSubscriptions.length) {\n                    _context2.next = 12;\n                    break;\n                  }\n\n                  _context2.next = 8;\n                  return this.realtime.disconnect();\n\n                case 8:\n                  _yield$this$realtime$ = _context2.sent;\n                  error = _yield$this$realtime$.error;\n\n                  if (!error) {\n                    _context2.next = 12;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\", resolve({\n                    error: error\n                  }));\n\n                case 12:\n                  return _context2.abrupt(\"return\", resolve({\n                    error: null,\n                    data: {\n                      openSubscriptions: openSubscriptionsCount\n                    }\n                  }));\n\n                case 15:\n                  _context2.prev = 15;\n                  _context2.t0 = _context2[\"catch\"](0);\n                  return _context2.abrupt(\"return\", resolve({\n                    error: _context2.t0\n                  }));\n\n                case 18:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this, [[0, 15]]);\n        }));\n      });\n    }\n  }, {\n    key: \"_closeSubscription\",\n    value: function _closeSubscription(subscription) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (subscription.isClosed()) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this._closeChannel(subscription);\n\n              case 3:\n                return _context3.abrupt(\"return\", new Promise(function (resolve) {\n                  _this3.realtime.remove(subscription);\n\n                  return resolve(true);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Returns an array of all your subscriptions.\n     */\n\n  }, {\n    key: \"getSubscriptions\",\n    value: function getSubscriptions() {\n      return this.realtime.channels;\n    }\n  }, {\n    key: \"_initSupabaseAuthClient\",\n    value: function _initSupabaseAuthClient(_ref2) {\n      var autoRefreshToken = _ref2.autoRefreshToken,\n          persistSession = _ref2.persistSession,\n          detectSessionInUrl = _ref2.detectSessionInUrl,\n          localStorage = _ref2.localStorage,\n          headers = _ref2.headers,\n          fetch = _ref2.fetch;\n      var authHeaders = {\n        Authorization: \"Bearer \".concat(this.supabaseKey),\n        apikey: \"\".concat(this.supabaseKey)\n      };\n      return new SupabaseAuthClient({\n        url: this.authUrl,\n        headers: Object.assign(Object.assign({}, headers), authHeaders),\n        autoRefreshToken: autoRefreshToken,\n        persistSession: persistSession,\n        detectSessionInUrl: detectSessionInUrl,\n        localStorage: localStorage,\n        fetch: fetch\n      });\n    }\n  }, {\n    key: \"_initRealtimeClient\",\n    value: function _initRealtimeClient(options) {\n      return new RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {\n        params: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.params), {\n          apikey: this.supabaseKey\n        })\n      }));\n    }\n  }, {\n    key: \"_initPostgRESTClient\",\n    value: function _initPostgRESTClient() {\n      return new PostgrestClient(this.restUrl, {\n        headers: this._getAuthHeaders(),\n        schema: this.schema,\n        fetch: this.fetch\n      });\n    }\n  }, {\n    key: \"_getAuthHeaders\",\n    value: function _getAuthHeaders() {\n      var _a, _b;\n\n      var headers = this.headers;\n      var authBearer = (_b = (_a = this.auth.session()) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n      headers['apikey'] = this.supabaseKey;\n      headers['Authorization'] = \"Bearer \".concat(authBearer);\n      return headers;\n    }\n  }, {\n    key: \"_closeChannel\",\n    value: function _closeChannel(subscription) {\n      return new Promise(function (resolve, reject) {\n        subscription.unsubscribe().receive('ok', function () {\n          return resolve(true);\n        }).receive('error', function (e) {\n          return reject(e);\n        });\n      });\n    }\n  }, {\n    key: \"_listenForMultiTabEvents\",\n    value: function _listenForMultiTabEvents() {\n      var _this4 = this;\n\n      if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        return null;\n      }\n\n      try {\n        return window === null || window === void 0 ? void 0 : window.addEventListener('storage', function (e) {\n          var _a, _b, _c;\n\n          if (e.key === STORAGE_KEY) {\n            var newSession = JSON.parse(String(e.newValue));\n            var accessToken = (_b = (_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n            var previousAccessToken = (_c = _this4.auth.session()) === null || _c === void 0 ? void 0 : _c.access_token;\n\n            if (!accessToken) {\n              _this4._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE');\n            } else if (!previousAccessToken && accessToken) {\n              _this4._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE');\n            } else if (previousAccessToken !== accessToken) {\n              _this4._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE');\n            }\n          }\n        });\n      } catch (error) {\n        console.error('_listenForMultiTabEvents', error);\n        return null;\n      }\n    }\n  }, {\n    key: \"_listenForAuthEvents\",\n    value: function _listenForAuthEvents() {\n      var _this5 = this;\n\n      var _this$auth$onAuthStat = this.auth.onAuthStateChange(function (event, session) {\n        _this5._handleTokenChanged(event, session === null || session === void 0 ? void 0 : session.access_token, 'CLIENT');\n      }),\n          data = _this$auth$onAuthStat.data;\n\n      return data;\n    }\n  }, {\n    key: \"_handleTokenChanged\",\n    value: function _handleTokenChanged(event, token, source) {\n      if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n        // Token has changed\n        this.realtime.setAuth(token); // Ideally we should call this.auth.recoverSession() - need to make public\n        // to trigger a \"SIGNED_IN\" event on this client.\n\n        if (source == 'STORAGE') this.auth.setAuth(token);\n        this.changedAccessToken = token;\n      } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n        // Token is removed\n        this.removeAllSubscriptions();\n        if (source == 'STORAGE') this.auth.signOut();\n      }\n    }\n  }]);\n\n  return SupabaseClient;\n}();\n\nexport { SupabaseClient as default };","map":{"version":3,"sources":["C:\\Users\\Dave\\WebstormProjects\\wappsite\\node_modules\\@supabase\\supabase-js\\src\\SupabaseClient.ts"],"names":[],"mappings":"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","sourcesContent":["import { DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants'\nimport { stripTrailingSlash, isBrowser } from './lib/helpers'\nimport { Fetch, SupabaseClientOptions } from './lib/types'\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\nimport { SupabaseQueryBuilder } from './lib/SupabaseQueryBuilder'\nimport { SupabaseStorageClient } from '@supabase/storage-js'\nimport { PostgrestClient } from '@supabase/postgrest-js'\nimport { AuthChangeEvent, Session, Subscription } from '@supabase/gotrue-js'\nimport { RealtimeClient, RealtimeSubscription, RealtimeClientOptions } from '@supabase/realtime-js'\n\nconst DEFAULT_OPTIONS = {\n  schema: 'public',\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */\nexport default class SupabaseClient {\n  /**\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\n   */\n  auth: SupabaseAuthClient\n\n  protected schema: string\n  protected restUrl: string\n  protected realtimeUrl: string\n  protected authUrl: string\n  protected storageUrl: string\n  protected realtime: RealtimeClient\n  protected multiTab: boolean\n  protected fetch?: Fetch\n  protected changedAccessToken: string | undefined\n  protected headers: {\n    [key: string]: string\n  }\n\n  /**\n   * Create a new client for use in the browser.\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n   * @param options.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.headers Any additional headers to send with each network request.\n   * @param options.realtime Options passed along to realtime-js constructor.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(\n    protected supabaseUrl: string,\n    protected supabaseKey: string,\n    options?: SupabaseClientOptions\n  ) {\n    if (!supabaseUrl) throw new Error('supabaseUrl is required.')\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\n\n    supabaseUrl = stripTrailingSlash(supabaseUrl)\n\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.restUrl = `${supabaseUrl}/rest/v1`\n    this.realtimeUrl = `${supabaseUrl}/realtime/v1`.replace('http', 'ws')\n    this.authUrl = `${supabaseUrl}/auth/v1`\n    this.storageUrl = `${supabaseUrl}/storage/v1`\n    this.schema = settings.schema\n    this.multiTab = settings.multiTab\n    this.fetch = settings.fetch\n    this.headers = { ...DEFAULT_HEADERS, ...options?.headers }\n\n    this.auth = this._initSupabaseAuthClient(settings)\n    this.realtime = this._initRealtimeClient({ headers: this.headers, ...settings.realtime })\n\n    this._listenForAuthEvents()\n    this._listenForMultiTabEvents()\n\n    // In the future we might allow the user to pass in a logger to receive these events.\n    // this.realtime.onOpen(() => console.log('OPEN'))\n    // this.realtime.onClose(() => console.log('CLOSED'))\n    // this.realtime.onError((e: Error) => console.log('Socket error', e))\n  }\n\n  /**\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\n   */\n  get storage() {\n    return new SupabaseStorageClient(this.storageUrl, this._getAuthHeaders(), this.fetch)\n  }\n\n  /**\n   * Perform a table operation.\n   *\n   * @param table The table name to operate on.\n   */\n  from<T = any>(table: string): SupabaseQueryBuilder<T> {\n    const url = `${this.restUrl}/${table}`\n    return new SupabaseQueryBuilder<T>(url, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      realtime: this.realtime,\n      table,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn  The function name to call.\n   * @param params  The parameters to pass to the function call.\n   * @param head   When set to true, no data will be returned.\n   * @param count  Count algorithm to use to count rows in a table.\n   *\n   */\n  rpc<T = any>(\n    fn: string,\n    params?: object,\n    {\n      head = false,\n      count = null,\n    }: { head?: boolean; count?: null | 'exact' | 'planned' | 'estimated' } = {}\n  ) {\n    const rest = this._initPostgRESTClient()\n    return rest.rpc<T>(fn, params, { head, count })\n  }\n\n  /**\n   * Remove all subscriptions.\n   */\n  async removeAllSubscriptions() {\n    const subscriptions = this.realtime.channels.slice()\n    return await Promise.allSettled(subscriptions.map((sub) => this.removeSubscription(sub)))\n  }\n\n  /**\n   * Removes an active subscription and returns the number of open connections.\n   *\n   * @param subscription The subscription you want to remove.\n   */\n  removeSubscription(subscription: RealtimeSubscription) {\n    return new Promise(async (resolve) => {\n      try {\n        await this._closeSubscription(subscription)\n\n        const allSubscriptions = this.getSubscriptions()\n        const openSubscriptionsCount = allSubscriptions.filter((chan) => chan.isJoined()).length\n\n        if (!allSubscriptions.length) {\n          const { error } = await this.realtime.disconnect()\n          if (error) return resolve({ error })\n        }\n        return resolve({ error: null, data: { openSubscriptions: openSubscriptionsCount } })\n      } catch (error) {\n        return resolve({ error })\n      }\n    })\n  }\n\n  private async _closeSubscription(subscription: RealtimeSubscription) {\n    if (!subscription.isClosed()) {\n      await this._closeChannel(subscription)\n    }\n\n    return new Promise((resolve) => {\n      this.realtime.remove(subscription)\n      return resolve(true)\n    })\n  }\n\n  /**\n   * Returns an array of all your subscriptions.\n   */\n  getSubscriptions(): RealtimeSubscription[] {\n    return this.realtime.channels\n  }\n\n  private _initSupabaseAuthClient({\n    autoRefreshToken,\n    persistSession,\n    detectSessionInUrl,\n    localStorage,\n    headers,\n    fetch,\n  }: SupabaseClientOptions) {\n    const authHeaders = {\n      Authorization: `Bearer ${this.supabaseKey}`,\n      apikey: `${this.supabaseKey}`,\n    }\n    return new SupabaseAuthClient({\n      url: this.authUrl,\n      headers: { ...headers, ...authHeaders },\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      localStorage,\n      fetch,\n    })\n  }\n\n  private _initRealtimeClient(options?: RealtimeClientOptions) {\n    return new RealtimeClient(this.realtimeUrl, {\n      ...options,\n      params: { ...options?.params, apikey: this.supabaseKey },\n    })\n  }\n\n  private _initPostgRESTClient() {\n    return new PostgrestClient(this.restUrl, {\n      headers: this._getAuthHeaders(),\n      schema: this.schema,\n      fetch: this.fetch,\n    })\n  }\n\n  private _getAuthHeaders(): { [key: string]: string } {\n    const headers: { [key: string]: string } = this.headers\n    const authBearer = this.auth.session()?.access_token ?? this.supabaseKey\n    headers['apikey'] = this.supabaseKey\n    headers['Authorization'] = `Bearer ${authBearer}`\n    return headers\n  }\n\n  private _closeChannel(subscription: RealtimeSubscription) {\n    return new Promise((resolve, reject) => {\n      subscription\n        .unsubscribe()\n        .receive('ok', () => {\n          return resolve(true)\n        })\n        .receive('error', (e: Error) => reject(e))\n    })\n  }\n\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      return null\n    }\n\n    try {\n      return window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          const accessToken: string | undefined =\n            newSession?.currentSession?.access_token ?? undefined\n          const previousAccessToken = this.auth.session()?.access_token\n          if (!accessToken) {\n            this._handleTokenChanged('SIGNED_OUT', accessToken, 'STORAGE')\n          } else if (!previousAccessToken && accessToken) {\n            this._handleTokenChanged('SIGNED_IN', accessToken, 'STORAGE')\n          } else if (previousAccessToken !== accessToken) {\n            this._handleTokenChanged('TOKEN_REFRESHED', accessToken, 'STORAGE')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n      return null\n    }\n  }\n\n  private _listenForAuthEvents() {\n    let { data } = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, session?.access_token, 'CLIENT')\n    })\n    return data\n  }\n\n  private _handleTokenChanged(\n    event: AuthChangeEvent,\n    token: string | undefined,\n    source: 'CLIENT' | 'STORAGE'\n  ) {\n    if (\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\n      this.changedAccessToken !== token\n    ) {\n      // Token has changed\n      this.realtime.setAuth(token!)\n      // Ideally we should call this.auth.recoverSession() - need to make public\n      // to trigger a \"SIGNED_IN\" event on this client.\n      if (source == 'STORAGE') this.auth.setAuth(token!)\n\n      this.changedAccessToken = token\n    } else if (event === 'SIGNED_OUT' || event === 'USER_DELETED') {\n      // Token is removed\n      this.removeAllSubscriptions()\n      if (source == 'STORAGE') this.auth.signOut()\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}