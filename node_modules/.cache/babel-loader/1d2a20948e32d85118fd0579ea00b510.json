{"ast":null,"code":"import _toConsumableArray from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _classCallCheck from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _inherits from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport { PostgrestBuilder } from './types';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\n\nvar PostgrestQueryBuilder = /*#__PURE__*/function (_PostgrestBuilder) {\n  _inherits(PostgrestQueryBuilder, _PostgrestBuilder);\n\n  var _super = _createSuper(PostgrestQueryBuilder);\n\n  function PostgrestQueryBuilder(url) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$headers = _ref.headers,\n        headers = _ref$headers === void 0 ? {} : _ref$headers,\n        schema = _ref.schema,\n        fetch = _ref.fetch;\n\n    _classCallCheck(this, PostgrestQueryBuilder);\n\n    _this = _super.call(this, {\n      fetch: fetch\n    });\n    _this.url = new URL(url);\n    _this.headers = Object.assign({}, headers);\n    _this.schema = schema;\n    return _this;\n  }\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   * @param head  When set to true, select will void data.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n\n\n  _createClass(PostgrestQueryBuilder, [{\n    key: \"select\",\n    value: function select() {\n      var columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$head = _ref2.head,\n          head = _ref2$head === void 0 ? false : _ref2$head,\n          _ref2$count = _ref2.count,\n          count = _ref2$count === void 0 ? null : _ref2$count;\n\n      this.method = 'GET'; // Remove whitespaces except when quoted\n\n      var quoted = false;\n      var cleanedColumns = columns.split('').map(function (c) {\n        if (/\\s/.test(c) && !quoted) {\n          return '';\n        }\n\n        if (c === '\"') {\n          quoted = !quoted;\n        }\n\n        return c;\n      }).join('');\n      this.url.searchParams.set('select', cleanedColumns);\n\n      if (count) {\n        this.headers['Prefer'] = \"count=\".concat(count);\n      }\n\n      if (head) {\n        this.method = 'HEAD';\n      }\n\n      return new PostgrestFilterBuilder(this);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(values) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref3$upsert = _ref3.upsert,\n          upsert = _ref3$upsert === void 0 ? false : _ref3$upsert,\n          onConflict = _ref3.onConflict,\n          _ref3$returning = _ref3.returning,\n          returning = _ref3$returning === void 0 ? 'representation' : _ref3$returning,\n          _ref3$count = _ref3.count,\n          count = _ref3$count === void 0 ? null : _ref3$count;\n\n      this.method = 'POST';\n      var prefersHeaders = [\"return=\".concat(returning)];\n      if (upsert) prefersHeaders.push('resolution=merge-duplicates');\n      if (upsert && onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n      this.body = values;\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n\n      if (Array.isArray(values)) {\n        var columns = values.reduce(function (acc, x) {\n          return acc.concat(Object.keys(x));\n        }, []);\n\n        if (columns.length > 0) {\n          var uniqueColumns = _toConsumableArray(new Set(columns)).map(function (column) {\n            return \"\\\"\".concat(column, \"\\\"\");\n          });\n\n          this.url.searchParams.set('columns', uniqueColumns.join(','));\n        }\n      }\n\n      return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs an UPSERT into the table.\n     *\n     * @param values  The values to insert.\n     * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\n     * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\n     */\n\n  }, {\n    key: \"upsert\",\n    value: function upsert(values) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onConflict = _ref4.onConflict,\n          _ref4$returning = _ref4.returning,\n          returning = _ref4$returning === void 0 ? 'representation' : _ref4$returning,\n          _ref4$count = _ref4.count,\n          count = _ref4$count === void 0 ? null : _ref4$count,\n          _ref4$ignoreDuplicate = _ref4.ignoreDuplicates,\n          ignoreDuplicates = _ref4$ignoreDuplicate === void 0 ? false : _ref4$ignoreDuplicate;\n\n      this.method = 'POST';\n      var prefersHeaders = [\"resolution=\".concat(ignoreDuplicates ? 'ignore' : 'merge', \"-duplicates\"), \"return=\".concat(returning)];\n      if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);\n      this.body = values;\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs an UPDATE on the table.\n     *\n     * @param values  The values to update.\n     * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(values) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref5$returning = _ref5.returning,\n          returning = _ref5$returning === void 0 ? 'representation' : _ref5$returning,\n          _ref5$count = _ref5.count,\n          count = _ref5$count === void 0 ? null : _ref5$count;\n\n      this.method = 'PATCH';\n      var prefersHeaders = [\"return=\".concat(returning)];\n      this.body = values;\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      return new PostgrestFilterBuilder(this);\n    }\n    /**\n     * Performs a DELETE on the table.\n     *\n     * @param returning  If `true`, return the deleted row(s) in the response.\n     * @param count  Count algorithm to use to count rows in a table.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$returning = _ref6.returning,\n          returning = _ref6$returning === void 0 ? 'representation' : _ref6$returning,\n          _ref6$count = _ref6.count,\n          count = _ref6$count === void 0 ? null : _ref6$count;\n\n      this.method = 'DELETE';\n      var prefersHeaders = [\"return=\".concat(returning)];\n\n      if (count) {\n        prefersHeaders.push(\"count=\".concat(count));\n      }\n\n      this.headers['Prefer'] = prefersHeaders.join(',');\n      return new PostgrestFilterBuilder(this);\n    }\n  }]);\n\n  return PostgrestQueryBuilder;\n}(PostgrestBuilder);\n\nexport { PostgrestQueryBuilder as default };","map":{"version":3,"sources":["C:\\Users\\Dave\\WebstormProjects\\wappsite\\node_modules\\@supabase\\postgrest-js\\src\\lib\\PostgrestQueryBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Fetch, PostgrestBuilder } from './types'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\n\nexport default class PostgrestQueryBuilder<T> extends PostgrestBuilder<T> {\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: { headers?: { [key: string]: string }; schema?: string; fetch?: Fetch } = {}\n  ) {\n    super(({ fetch } as unknown) as PostgrestBuilder<T>)\n    this.url = new URL(url)\n    this.headers = { ...headers }\n    this.schema = schema\n  }\n\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   * @param head  When set to true, select will void data.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  select(\n    columns = '*',\n    {\n      head = false,\n      count = null,\n    }: {\n      head?: boolean\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = columns\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n    if (head) {\n      this.method = 'HEAD'\n    }\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs an INSERT into the table.\n   *\n   * @param values  The values to insert.\n   * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  insert(\n    values: Partial<T> | Partial<T>[],\n    options?: {\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<T>\n  /**\n   * @deprecated Use `upsert()` instead.\n   */\n  insert(\n    values: Partial<T> | Partial<T>[],\n    options?: {\n      upsert?: boolean\n      onConflict?: string\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<T>\n  insert(\n    values: Partial<T> | Partial<T>[],\n    {\n      upsert = false,\n      onConflict,\n      returning = 'representation',\n      count = null,\n    }: {\n      upsert?: boolean\n      onConflict?: string\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'POST'\n\n    const prefersHeaders = [`return=${returning}`]\n    if (upsert) prefersHeaders.push('resolution=merge-duplicates')\n\n    if (upsert && onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    this.body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs an UPSERT into the table.\n   *\n   * @param values  The values to insert.\n   * @param onConflict  By specifying the `on_conflict` query parameter, you can make UPSERT work on a column(s) that has a UNIQUE constraint.\n   * @param returning  By default the new record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   * @param ignoreDuplicates  Specifies if duplicate rows should be ignored and not inserted.\n   */\n  upsert(\n    values: Partial<T> | Partial<T>[],\n    {\n      onConflict,\n      returning = 'representation',\n      count = null,\n      ignoreDuplicates = false,\n    }: {\n      onConflict?: string\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n      ignoreDuplicates?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'POST'\n\n    const prefersHeaders = [\n      `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`,\n      `return=${returning}`,\n    ]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    this.body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs an UPDATE on the table.\n   *\n   * @param values  The values to update.\n   * @param returning  By default the updated record is returned. Set this to 'minimal' if you don't need this value.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  update(\n    values: Partial<T>,\n    {\n      returning = 'representation',\n      count = null,\n    }: {\n      returning?: 'minimal' | 'representation'\n      count?: null | 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<T> {\n    this.method = 'PATCH'\n    const prefersHeaders = [`return=${returning}`]\n    this.body = values\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n    return new PostgrestFilterBuilder(this)\n  }\n\n  /**\n   * Performs a DELETE on the table.\n   *\n   * @param returning  If `true`, return the deleted row(s) in the response.\n   * @param count  Count algorithm to use to count rows in a table.\n   */\n  delete({\n    returning = 'representation',\n    count = null,\n  }: {\n    returning?: 'minimal' | 'representation'\n    count?: null | 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<T> {\n    this.method = 'DELETE'\n    const prefersHeaders = [`return=${returning}`]\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n    return new PostgrestFilterBuilder(this)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}