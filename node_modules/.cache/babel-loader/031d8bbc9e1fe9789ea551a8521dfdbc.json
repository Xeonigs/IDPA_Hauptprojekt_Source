{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants';\nimport Push from './lib/push';\nimport Timer from './lib/timer';\n\nvar RealtimeSubscription = /*#__PURE__*/function () {\n  function RealtimeSubscription(topic) {\n    var _this = this;\n\n    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var socket = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, RealtimeSubscription);\n\n    this.topic = topic;\n    this.params = params;\n    this.socket = socket;\n    this.bindings = [];\n    this.state = CHANNEL_STATES.closed;\n    this.joinedOnce = false;\n    this.pushBuffer = [];\n    this.timeout = this.socket.timeout;\n    this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);\n    this.rejoinTimer = new Timer(function () {\n      return _this.rejoinUntilConnected();\n    }, this.socket.reconnectAfterMs);\n    this.joinPush.receive('ok', function () {\n      _this.state = CHANNEL_STATES.joined;\n\n      _this.rejoinTimer.reset();\n\n      _this.pushBuffer.forEach(function (pushEvent) {\n        return pushEvent.send();\n      });\n\n      _this.pushBuffer = [];\n    });\n    this.onClose(function () {\n      _this.rejoinTimer.reset();\n\n      _this.socket.log('channel', \"close \".concat(_this.topic, \" \").concat(_this.joinRef()));\n\n      _this.state = CHANNEL_STATES.closed;\n\n      _this.socket.remove(_this);\n    });\n    this.onError(function (reason) {\n      if (_this.isLeaving() || _this.isClosed()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"error \".concat(_this.topic), reason);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.joinPush.receive('timeout', function () {\n      if (!_this.isJoining()) {\n        return;\n      }\n\n      _this.socket.log('channel', \"timeout \".concat(_this.topic), _this.joinPush.timeout);\n\n      _this.state = CHANNEL_STATES.errored;\n\n      _this.rejoinTimer.scheduleTimeout();\n    });\n    this.on(CHANNEL_EVENTS.reply, function (payload, ref) {\n      _this.trigger(_this.replyEventName(ref), payload);\n    });\n  }\n\n  _createClass(RealtimeSubscription, [{\n    key: \"rejoinUntilConnected\",\n    value: function rejoinUntilConnected() {\n      this.rejoinTimer.scheduleTimeout();\n\n      if (this.socket.isConnected()) {\n        this.rejoin();\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.joinedOnce) {\n        throw \"tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance\";\n      } else {\n        this.joinedOnce = true;\n        this.rejoin(timeout);\n        return this.joinPush;\n      }\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose(callback) {\n      this.on(CHANNEL_EVENTS.close, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(CHANNEL_EVENTS.error, function (reason) {\n        return callback(reason);\n      });\n    }\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      this.bindings.push({\n        event: event,\n        callback: callback\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off(event) {\n      this.bindings = this.bindings.filter(function (bind) {\n        return bind.event !== event;\n      });\n    }\n  }, {\n    key: \"canPush\",\n    value: function canPush() {\n      return this.socket.isConnected() && this.isJoined();\n    }\n  }, {\n    key: \"push\",\n    value: function push(event, payload) {\n      var timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.timeout;\n\n      if (!this.joinedOnce) {\n        throw \"tried to push '\".concat(event, \"' to '\").concat(this.topic, \"' before joining. Use channel.subscribe() before pushing events\");\n      }\n\n      var pushEvent = new Push(this, event, payload, timeout);\n\n      if (this.canPush()) {\n        pushEvent.send();\n      } else {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n      }\n\n      return pushEvent;\n    }\n  }, {\n    key: \"updateJoinPayload\",\n    value: function updateJoinPayload(payload) {\n      this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe() {\n      var _this2 = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n      this.state = CHANNEL_STATES.leaving;\n\n      var onClose = function onClose() {\n        _this2.socket.log('channel', \"leave \".concat(_this2.topic));\n\n        _this2.trigger(CHANNEL_EVENTS.close, 'leave', _this2.joinRef());\n      }; // Destroy joinPush to avoid connection timeouts during unscription phase\n\n\n      this.joinPush.destroy();\n      var leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout);\n      leavePush.receive('ok', function () {\n        return onClose();\n      }).receive('timeout', function () {\n        return onClose();\n      });\n      leavePush.send();\n\n      if (!this.canPush()) {\n        leavePush.trigger('ok', {});\n      }\n\n      return leavePush;\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     */\n\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(event, payload, ref) {\n      return payload;\n    }\n  }, {\n    key: \"isMember\",\n    value: function isMember(topic) {\n      return this.topic === topic;\n    }\n  }, {\n    key: \"joinRef\",\n    value: function joinRef() {\n      return this.joinPush.ref;\n    }\n  }, {\n    key: \"sendJoin\",\n    value: function sendJoin(timeout) {\n      this.state = CHANNEL_STATES.joining;\n      this.joinPush.resend(timeout);\n    }\n  }, {\n    key: \"rejoin\",\n    value: function rejoin() {\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.timeout;\n\n      if (this.isLeaving()) {\n        return;\n      }\n\n      this.sendJoin(timeout);\n    }\n  }, {\n    key: \"trigger\",\n    value: function trigger(event, payload, ref) {\n      var close = CHANNEL_EVENTS.close,\n          error = CHANNEL_EVENTS.error,\n          leave = CHANNEL_EVENTS.leave,\n          join = CHANNEL_EVENTS.join;\n      var events = [close, error, leave, join];\n\n      if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n        return;\n      }\n\n      var handledPayload = this.onMessage(event, payload, ref);\n\n      if (payload && !handledPayload) {\n        throw 'channel onMessage callbacks must return the payload, modified or unmodified';\n      }\n\n      this.bindings.filter(function (bind) {\n        // Bind all events if the user specifies a wildcard.\n        if (bind.event === '*') {\n          return event === (payload === null || payload === void 0 ? void 0 : payload.type);\n        } else {\n          return bind.event === event;\n        }\n      }).map(function (bind) {\n        return bind.callback(handledPayload, ref);\n      });\n    }\n  }, {\n    key: \"replyEventName\",\n    value: function replyEventName(ref) {\n      return \"chan_reply_\".concat(ref);\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed() {\n      return this.state === CHANNEL_STATES.closed;\n    }\n  }, {\n    key: \"isErrored\",\n    value: function isErrored() {\n      return this.state === CHANNEL_STATES.errored;\n    }\n  }, {\n    key: \"isJoined\",\n    value: function isJoined() {\n      return this.state === CHANNEL_STATES.joined;\n    }\n  }, {\n    key: \"isJoining\",\n    value: function isJoining() {\n      return this.state === CHANNEL_STATES.joining;\n    }\n  }, {\n    key: \"isLeaving\",\n    value: function isLeaving() {\n      return this.state === CHANNEL_STATES.leaving;\n    }\n  }]);\n\n  return RealtimeSubscription;\n}();\n\nexport { RealtimeSubscription as default };","map":{"version":3,"sources":["C:\\Users\\Dave\\WebstormProjects\\wappsite\\node_modules\\@supabase\\realtime-js\\src\\RealtimeSubscription.ts"],"names":[],"mappings":";;AAAA,SAAS,cAAT,EAAyB,cAAzB,QAA+C,iBAA/C;AACA,OAAO,IAAP,MAAiB,YAAjB;AAEA,OAAO,KAAP,MAAkB,aAAlB;;IAEqB,oB;AASnB,gCACS,KADT,EAG+B;AAAA;;AAAA,QADtB,MACsB,uEADe,EACf;AAAA,QAAtB,MAAsB;;AAAA;;AAFtB,SAAA,KAAA,GAAA,KAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,MAAA,GAAA,MAAA;AAXT,SAAA,QAAA,GAAkB,EAAlB;AAEA,SAAA,KAAA,GAAQ,cAAc,CAAC,MAAvB;AACA,SAAA,UAAA,GAAa,KAAb;AAGA,SAAA,UAAA,GAAqB,EAArB;AAOE,SAAK,OAAL,GAAe,KAAK,MAAL,CAAY,OAA3B;AACA,SAAK,QAAL,GAAgB,IAAI,IAAJ,CACd,IADc,EAEd,cAAc,CAAC,IAFD,EAGd,KAAK,MAHS,EAId,KAAK,OAJS,CAAhB;AAMA,SAAK,WAAL,GAAmB,IAAI,KAAJ,CACjB;AAAA,aAAM,KAAI,CAAC,oBAAL,EAAN;AAAA,KADiB,EAEjB,KAAK,MAAL,CAAY,gBAFK,CAAnB;AAIA,SAAK,QAAL,CAAc,OAAd,CAAsB,IAAtB,EAA4B,YAAK;AAC/B,MAAA,KAAI,CAAC,KAAL,GAAa,cAAc,CAAC,MAA5B;;AACA,MAAA,KAAI,CAAC,WAAL,CAAiB,KAAjB;;AACA,MAAA,KAAI,CAAC,UAAL,CAAgB,OAAhB,CAAwB,UAAC,SAAD;AAAA,eAAqB,SAAS,CAAC,IAAV,EAArB;AAAA,OAAxB;;AACA,MAAA,KAAI,CAAC,UAAL,GAAkB,EAAlB;AACD,KALD;AAMA,SAAK,OAAL,CAAa,YAAK;AAChB,MAAA,KAAI,CAAC,WAAL,CAAiB,KAAjB;;AACA,MAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,SAAhB,kBAAoC,KAAI,CAAC,KAAzC,cAAkD,KAAI,CAAC,OAAL,EAAlD;;AACA,MAAA,KAAI,CAAC,KAAL,GAAa,cAAc,CAAC,MAA5B;;AACA,MAAA,KAAI,CAAC,MAAL,CAAY,MAAZ,CAAmB,KAAnB;AACD,KALD;AAMA,SAAK,OAAL,CAAa,UAAC,MAAD,EAAmB;AAC9B,UAAI,KAAI,CAAC,SAAL,MAAoB,KAAI,CAAC,QAAL,EAAxB,EAAyC;AACvC;AACD;;AACD,MAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,SAAhB,kBAAoC,KAAI,CAAC,KAAzC,GAAkD,MAAlD;;AACA,MAAA,KAAI,CAAC,KAAL,GAAa,cAAc,CAAC,OAA5B;;AACA,MAAA,KAAI,CAAC,WAAL,CAAiB,eAAjB;AACD,KAPD;AAQA,SAAK,QAAL,CAAc,OAAd,CAAsB,SAAtB,EAAiC,YAAK;AACpC,UAAI,CAAC,KAAI,CAAC,SAAL,EAAL,EAAuB;AACrB;AACD;;AACD,MAAA,KAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,SAAhB,oBAAsC,KAAI,CAAC,KAA3C,GAAoD,KAAI,CAAC,QAAL,CAAc,OAAlE;;AACA,MAAA,KAAI,CAAC,KAAL,GAAa,cAAc,CAAC,OAA5B;;AACA,MAAA,KAAI,CAAC,WAAL,CAAiB,eAAjB;AACD,KAPD;AAQA,SAAK,EAAL,CAAQ,cAAc,CAAC,KAAvB,EAA8B,UAAC,OAAD,EAAe,GAAf,EAA8B;AAC1D,MAAA,KAAI,CAAC,OAAL,CAAa,KAAI,CAAC,cAAL,CAAoB,GAApB,CAAb,EAAuC,OAAvC;AACD,KAFD;AAGD;;;;WAED,gCAAoB;AAClB,WAAK,WAAL,CAAiB,eAAjB;;AACA,UAAI,KAAK,MAAL,CAAY,WAAZ,EAAJ,EAA+B;AAC7B,aAAK,MAAL;AACD;AACF;;;WAED,qBAAgC;AAAA,UAAtB,OAAsB,uEAAZ,KAAK,OAAO;;AAC9B,UAAI,KAAK,UAAT,EAAqB;AACnB;AACD,OAFD,MAEO;AACL,aAAK,UAAL,GAAkB,IAAlB;AACA,aAAK,MAAL,CAAY,OAAZ;AACA,eAAO,KAAK,QAAZ;AACD;AACF;;;WAED,iBAAQ,QAAR,EAA0B;AACxB,WAAK,EAAL,CAAQ,cAAc,CAAC,KAAvB,EAA8B,QAA9B;AACD;;;WAED,iBAAQ,QAAR,EAA0B;AACxB,WAAK,EAAL,CAAQ,cAAc,CAAC,KAAvB,EAA8B,UAAC,MAAD;AAAA,eAAoB,QAAQ,CAAC,MAAD,CAA5B;AAAA,OAA9B;AACD;;;WAED,YAAG,KAAH,EAAkB,QAAlB,EAAoC;AAClC,WAAK,QAAL,CAAc,IAAd,CAAmB;AAAE,QAAA,KAAK,EAAL,KAAF;AAAS,QAAA,QAAQ,EAAR;AAAT,OAAnB;AACD;;;WAED,aAAI,KAAJ,EAAiB;AACf,WAAK,QAAL,GAAgB,KAAK,QAAL,CAAc,MAAd,CAAqB,UAAC,IAAD;AAAA,eAAU,IAAI,CAAC,KAAL,KAAe,KAAzB;AAAA,OAArB,CAAhB;AACD;;;WAED,mBAAO;AACL,aAAO,KAAK,MAAL,CAAY,WAAZ,MAA6B,KAAK,QAAL,EAApC;AACD;;;WAED,cAAK,KAAL,EAA4B,OAA5B,EAAgE;AAAA,UAAtB,OAAsB,uEAAZ,KAAK,OAAO;;AAC9D,UAAI,CAAC,KAAK,UAAV,EAAsB;AACpB,uCAAwB,KAAxB,mBAAsC,KAAK,KAA3C;AACD;;AACD,UAAI,SAAS,GAAG,IAAI,IAAJ,CAAS,IAAT,EAAe,KAAf,EAAsB,OAAtB,EAA+B,OAA/B,CAAhB;;AACA,UAAI,KAAK,OAAL,EAAJ,EAAoB;AAClB,QAAA,SAAS,CAAC,IAAV;AACD,OAFD,MAEO;AACL,QAAA,SAAS,CAAC,YAAV;AACA,aAAK,UAAL,CAAgB,IAAhB,CAAqB,SAArB;AACD;;AAED,aAAO,SAAP;AACD;;;WAED,2BAAkB,OAAlB,EAAqD;AACnD,WAAK,QAAL,CAAc,aAAd,CAA4B,OAA5B;AACD;AAED;;;;;;;;AAQG;;;;WACH,uBAAkC;AAAA;;AAAA,UAAtB,OAAsB,uEAAZ,KAAK,OAAO;AAChC,WAAK,KAAL,GAAa,cAAc,CAAC,OAA5B;;AACA,UAAI,OAAO,GAAG,SAAV,OAAU,GAAK;AACjB,QAAA,MAAI,CAAC,MAAL,CAAY,GAAZ,CAAgB,SAAhB,kBAAoC,MAAI,CAAC,KAAzC;;AACA,QAAA,MAAI,CAAC,OAAL,CAAa,cAAc,CAAC,KAA5B,EAAmC,OAAnC,EAA4C,MAAI,CAAC,OAAL,EAA5C;AACD,OAHD,CAFgC,CAMhC;;;AACA,WAAK,QAAL,CAAc,OAAd;AAEA,UAAI,SAAS,GAAG,IAAI,IAAJ,CAAS,IAAT,EAAe,cAAc,CAAC,KAA9B,EAAqC,EAArC,EAAyC,OAAzC,CAAhB;AACA,MAAA,SAAS,CAAC,OAAV,CAAkB,IAAlB,EAAwB;AAAA,eAAM,OAAO,EAAb;AAAA,OAAxB,EAAyC,OAAzC,CAAiD,SAAjD,EAA4D;AAAA,eAAM,OAAO,EAAb;AAAA,OAA5D;AACA,MAAA,SAAS,CAAC,IAAV;;AACA,UAAI,CAAC,KAAK,OAAL,EAAL,EAAqB;AACnB,QAAA,SAAS,CAAC,OAAV,CAAkB,IAAlB,EAAwB,EAAxB;AACD;;AAED,aAAO,SAAP;AACD;AAED;;;;;AAKG;;;;WACH,mBAAU,KAAV,EAAyB,OAAzB,EAAuC,GAAvC,EAAmD;AACjD,aAAO,OAAP;AACD;;;WAED,kBAAS,KAAT,EAAsB;AACpB,aAAO,KAAK,KAAL,KAAe,KAAtB;AACD;;;WAED,mBAAO;AACL,aAAO,KAAK,QAAL,CAAc,GAArB;AACD;;;WAED,kBAAS,OAAT,EAAwB;AACtB,WAAK,KAAL,GAAa,cAAc,CAAC,OAA5B;AACA,WAAK,QAAL,CAAc,MAAd,CAAqB,OAArB;AACD;;;WAED,kBAA6B;AAAA,UAAtB,OAAsB,uEAAZ,KAAK,OAAO;;AAC3B,UAAI,KAAK,SAAL,EAAJ,EAAsB;AACpB;AACD;;AACD,WAAK,QAAL,CAAc,OAAd;AACD;;;WAED,iBAAQ,KAAR,EAAuB,OAAvB,EAAsC,GAAtC,EAAkD;AAChD,UAAM,KAAN,GAAoC,cAApC,CAAM,KAAN;AAAA,UAAa,KAAb,GAAoC,cAApC,CAAa,KAAb;AAAA,UAAoB,KAApB,GAAoC,cAApC,CAAoB,KAApB;AAAA,UAA2B,IAA3B,GAAoC,cAApC,CAA2B,IAA3B;AACA,UAAI,MAAM,GAAa,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsB,IAAtB,CAAvB;;AACA,UAAI,GAAG,IAAI,MAAM,CAAC,OAAP,CAAe,KAAf,KAAyB,CAAhC,IAAqC,GAAG,KAAK,KAAK,OAAL,EAAjD,EAAiE;AAC/D;AACD;;AACD,UAAI,cAAc,GAAG,KAAK,SAAL,CAAe,KAAf,EAAsB,OAAtB,EAA+B,GAA/B,CAArB;;AACA,UAAI,OAAO,IAAI,CAAC,cAAhB,EAAgC;AAC9B,cAAM,6EAAN;AACD;;AAED,WAAK,QAAL,CACG,MADH,CACU,UAAC,IAAD,EAAS;AACf;AACA,YAAI,IAAI,CAAC,KAAL,KAAe,GAAnB,EAAwB;AACtB,iBAAO,KAAK,MAAK,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,IAAd,CAAZ;AACD,SAFD,MAEO;AACL,iBAAO,IAAI,CAAC,KAAL,KAAe,KAAtB;AACD;AACF,OARH,EASG,GATH,CASO,UAAC,IAAD;AAAA,eAAU,IAAI,CAAC,QAAL,CAAc,cAAd,EAA8B,GAA9B,CAAV;AAAA,OATP;AAUD;;;WAED,wBAAe,GAAf,EAA0B;AACxB,kCAAqB,GAArB;AACD;;;WAED,oBAAQ;AACN,aAAO,KAAK,KAAL,KAAe,cAAc,CAAC,MAArC;AACD;;;WACD,qBAAS;AACP,aAAO,KAAK,KAAL,KAAe,cAAc,CAAC,OAArC;AACD;;;WACD,oBAAQ;AACN,aAAO,KAAK,KAAL,KAAe,cAAc,CAAC,MAArC;AACD;;;WACD,qBAAS;AACP,aAAO,KAAK,KAAL,KAAe,cAAc,CAAC,OAArC;AACD;;;WACD,qBAAS;AACP,aAAO,KAAK,KAAL,KAAe,cAAc,CAAC,OAArC;AACD;;;;;;SArNkB,oB","sourcesContent":["import { CHANNEL_EVENTS, CHANNEL_STATES } from './lib/constants'\nimport Push from './lib/push'\nimport RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\n\nexport default class RealtimeSubscription {\n  bindings: any[] = []\n  timeout: number\n  state = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n\n  constructor(\n    public topic: string,\n    public params: { [key: string]: unknown } = {},\n    public socket: RealtimeClient\n  ) {\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this.rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this.onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this.joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket.remove(this)\n    })\n    this.onError((reason: string) => {\n      if (this.isLeaving() || this.isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this.isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.on(CHANNEL_EVENTS.reply, (payload: any, ref: string) => {\n      this.trigger(this.replyEventName(ref), payload)\n    })\n  }\n\n  rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this.rejoin()\n    }\n  }\n\n  subscribe(timeout = this.timeout) {\n    if (this.joinedOnce) {\n      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`\n    } else {\n      this.joinedOnce = true\n      this.rejoin(timeout)\n      return this.joinPush\n    }\n  }\n\n  onClose(callback: Function) {\n    this.on(CHANNEL_EVENTS.close, callback)\n  }\n\n  onError(callback: Function) {\n    this.on(CHANNEL_EVENTS.error, (reason: string) => callback(reason))\n  }\n\n  on(event: string, callback: Function) {\n    this.bindings.push({ event, callback })\n  }\n\n  off(event: string) {\n    this.bindings = this.bindings.filter((bind) => bind.event !== event)\n  }\n\n  canPush() {\n    return this.socket.isConnected() && this.isJoined()\n  }\n\n  push(event: CHANNEL_EVENTS, payload: any, timeout = this.timeout) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this.canPush()) {\n      pushEvent.send()\n    } else {\n      pushEvent.startTimeout()\n      this.pushBuffer.push(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  updateJoinPayload(payload: { [key: string]: unknown }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout) {\n    this.state = CHANNEL_STATES.leaving\n    let onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this.trigger(CHANNEL_EVENTS.close, 'leave', this.joinRef())\n    }\n    // Destroy joinPush to avoid connection timeouts during unscription phase\n    this.joinPush.destroy()\n\n    let leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n    leavePush.receive('ok', () => onClose()).receive('timeout', () => onClose())\n    leavePush.send()\n    if (!this.canPush()) {\n      leavePush.trigger('ok', {})\n    }\n\n    return leavePush\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   */\n  onMessage(event: string, payload: any, ref?: string) {\n    return payload\n  }\n\n  isMember(topic: string) {\n    return this.topic === topic\n  }\n\n  joinRef() {\n    return this.joinPush.ref\n  }\n\n  sendJoin(timeout: number) {\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  rejoin(timeout = this.timeout) {\n    if (this.isLeaving()) {\n      return\n    }\n    this.sendJoin(timeout)\n  }\n\n  trigger(event: string, payload?: any, ref?: string) {\n    let { close, error, leave, join } = CHANNEL_EVENTS\n    let events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(event) >= 0 && ref !== this.joinRef()) {\n      return\n    }\n    let handledPayload = this.onMessage(event, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    this.bindings\n      .filter((bind) => {\n        // Bind all events if the user specifies a wildcard.\n        if (bind.event === '*') {\n          return event === payload?.type\n        } else {\n          return bind.event === event\n        }\n      })\n      .map((bind) => bind.callback(handledPayload, ref))\n  }\n\n  replyEventName(ref: string) {\n    return `chan_reply_${ref}`\n  }\n\n  isClosed() {\n    return this.state === CHANNEL_STATES.closed\n  }\n  isErrored() {\n    return this.state === CHANNEL_STATES.errored\n  }\n  isJoined() {\n    return this.state === CHANNEL_STATES.joined\n  }\n  isJoining() {\n    return this.state === CHANNEL_STATES.joining\n  }\n  isLeaving() {\n    return this.state === CHANNEL_STATES.leaving\n  }\n}\n"]},"metadata":{},"sourceType":"module"}