{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport GoTrueApi from './GoTrueApi';\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers';\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\n\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS\n};\n\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  function GoTrueClient(options) {\n    _classCallCheck(this, GoTrueClient);\n\n    this.stateChangeEmitters = new Map();\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.currentUser = null;\n    this.currentSession = null;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.multiTab = settings.multiTab;\n    this.localStorage = settings.localStorage || globalThis.localStorage;\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch\n    });\n\n    this._recoverSession();\n\n    this._recoverAndRefresh();\n\n    this._listenForMultiTabEvents();\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({\n        storeSession: true\n      }).then(function (_ref) {\n        var error = _ref.error;\n\n        if (error) {\n          console.error('Error getting session from URL.', error);\n        }\n      });\n    }\n  }\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   */\n\n\n  _createClass(GoTrueClient, [{\n    key: \"signUp\",\n    value: function signUp(_ref2) {\n      var email = _ref2.email,\n          password = _ref2.password,\n          phone = _ref2.phone;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _ref3, data, error, session, user;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n\n                this._removeSession();\n\n                if (!(phone && password)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 5;\n                return this.api.signUpWithPhone(phone, password, {\n                  data: options.data\n                });\n\n              case 5:\n                _context.t0 = _context.sent;\n                _context.next = 11;\n                break;\n\n              case 8:\n                _context.next = 10;\n                return this.api.signUpWithEmail(email, password, {\n                  redirectTo: options.redirectTo,\n                  data: options.data\n                });\n\n              case 10:\n                _context.t0 = _context.sent;\n\n              case 11:\n                _ref3 = _context.t0;\n                data = _ref3.data;\n                error = _ref3.error;\n\n                if (!error) {\n                  _context.next = 16;\n                  break;\n                }\n\n                throw error;\n\n              case 16:\n                if (data) {\n                  _context.next = 18;\n                  break;\n                }\n\n                throw 'An error occurred on sign up.';\n\n              case 18:\n                session = null;\n                user = null;\n\n                if (data.access_token) {\n                  session = data;\n                  user = session.user;\n\n                  this._saveSession(session);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                if (data.id) {\n                  user = data;\n                }\n\n                return _context.abrupt(\"return\", {\n                  user: user,\n                  session: session,\n                  error: null\n                });\n\n              case 25:\n                _context.prev = 25;\n                _context.t1 = _context[\"catch\"](0);\n                return _context.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context.t1\n                });\n\n              case 28:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 25]]);\n      }));\n    }\n    /**\n     * Log in an existing user, or login via a third-party provider.\n     * @type UserCredentials\n     * @param email The user's email address.\n     * @param password The user's password.\n     * @param refreshToken A valid refresh token that was returned on login.\n     * @param provider One of the providers supported by GoTrue.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param scopes A space-separated list of scopes granted to the OAuth application.\n     */\n\n  }, {\n    key: \"signIn\",\n    value: function signIn(_ref4) {\n      var email = _ref4.email,\n          phone = _ref4.phone,\n          password = _ref4.password,\n          refreshToken = _ref4.refreshToken,\n          provider = _ref4.provider;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$this$api$sendM, error, _yield$this$api$sendM2, _error, _yield$this$_callRefr, _error2;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n\n                this._removeSession();\n\n                if (!(email && !password)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 5;\n                return this.api.sendMagicLinkEmail(email, {\n                  redirectTo: options.redirectTo\n                });\n\n              case 5:\n                _yield$this$api$sendM = _context2.sent;\n                error = _yield$this$api$sendM.error;\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: error\n                });\n\n              case 8:\n                if (!(email && password)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._handleEmailSignIn(email, password, {\n                  redirectTo: options.redirectTo\n                }));\n\n              case 10:\n                if (!(phone && !password)) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                _context2.next = 13;\n                return this.api.sendMobileOTP(phone);\n\n              case 13:\n                _yield$this$api$sendM2 = _context2.sent;\n                _error = _yield$this$api$sendM2.error;\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _error\n                });\n\n              case 16:\n                if (!(phone && password)) {\n                  _context2.next = 18;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._handlePhoneSignIn(phone, password));\n\n              case 18:\n                if (!refreshToken) {\n                  _context2.next = 26;\n                  break;\n                }\n\n                _context2.next = 21;\n                return this._callRefreshToken(refreshToken);\n\n              case 21:\n                _yield$this$_callRefr = _context2.sent;\n                _error2 = _yield$this$_callRefr.error;\n\n                if (!_error2) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                throw _error2;\n\n              case 25:\n                return _context2.abrupt(\"return\", {\n                  user: this.currentUser,\n                  session: this.currentSession,\n                  error: null\n                });\n\n              case 26:\n                if (!provider) {\n                  _context2.next = 28;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._handleProviderSignIn(provider, {\n                  redirectTo: options.redirectTo,\n                  scopes: options.scopes\n                }));\n\n              case 28:\n                throw new Error(\"You must provide either an email, phone number or a third-party provider.\");\n\n              case 31:\n                _context2.prev = 31;\n                _context2.t0 = _context2[\"catch\"](0);\n                return _context2.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context2.t0\n                });\n\n              case 34:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 31]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     * @param phone The user's phone number.\n     * @param token The user's password.\n     * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n     */\n\n  }, {\n    key: \"verifyOTP\",\n    value: function verifyOTP(_ref5) {\n      var phone = _ref5.phone,\n          token = _ref5.token;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _yield$this$api$verif, data, error, session, user;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n\n                this._removeSession();\n\n                _context3.next = 4;\n                return this.api.verifyMobileOTP(phone, token, options);\n\n              case 4:\n                _yield$this$api$verif = _context3.sent;\n                data = _yield$this$api$verif.data;\n                error = _yield$this$api$verif.error;\n\n                if (!error) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                if (data) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                throw 'An error occurred on token verification.';\n\n              case 11:\n                session = null;\n                user = null;\n\n                if (data.access_token) {\n                  session = data;\n                  user = session.user;\n\n                  this._saveSession(session);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                if (data.id) {\n                  user = data;\n                }\n\n                return _context3.abrupt(\"return\", {\n                  user: user,\n                  session: session,\n                  error: null\n                });\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", {\n                  user: null,\n                  session: null,\n                  error: _context3.t0\n                });\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 18]]);\n      }));\n    }\n    /**\n     * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n     *\n     * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n     */\n\n  }, {\n    key: \"user\",\n    value: function user() {\n      return this.currentUser;\n    }\n    /**\n     * Returns the session data, if there is an active session.\n     */\n\n  }, {\n    key: \"session\",\n    value: function session() {\n      return this.currentSession;\n    }\n    /**\n     * Force refreshes the session including the user data in case it was updated in a different session.\n     */\n\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _yield$this$_callRefr2, error;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n\n                if ((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error('Not logged in.');\n\n              case 3:\n                _context4.next = 5;\n                return this._callRefreshToken();\n\n              case 5:\n                _yield$this$_callRefr2 = _context4.sent;\n                error = _yield$this$_callRefr2.error;\n\n                if (!error) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw error;\n\n              case 9:\n                return _context4.abrupt(\"return\", {\n                  data: this.currentSession,\n                  user: this.currentUser,\n                  error: null\n                });\n\n              case 12:\n                _context4.prev = 12;\n                _context4.t0 = _context4[\"catch\"](0);\n                return _context4.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  error: _context4.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Updates user data, if there is a logged in user.\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(attributes) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _yield$this$api$updat, user, error, session;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n\n                if ((_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                throw new Error('Not logged in.');\n\n              case 3:\n                _context5.next = 5;\n                return this.api.updateUser(this.currentSession.access_token, attributes);\n\n              case 5:\n                _yield$this$api$updat = _context5.sent;\n                user = _yield$this$api$updat.user;\n                error = _yield$this$api$updat.error;\n\n                if (!error) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (user) {\n                  _context5.next = 12;\n                  break;\n                }\n\n                throw Error('Invalid user data.');\n\n              case 12:\n                session = Object.assign(Object.assign({}, this.currentSession), {\n                  user: user\n                });\n\n                this._saveSession(session);\n\n                this._notifyAllSubscribers('USER_UPDATED');\n\n                return _context5.abrupt(\"return\", {\n                  data: user,\n                  user: user,\n                  error: null\n                });\n\n              case 18:\n                _context5.prev = 18;\n                _context5.t0 = _context5[\"catch\"](0);\n                return _context5.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  error: _context5.t0\n                });\n\n              case 21:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 18]]);\n      }));\n    }\n    /**\n     * Sets the session data from refresh_token and returns current Session and Error\n     * @param refresh_token a JWT token\n     */\n\n  }, {\n    key: \"setSession\",\n    value: function setSession(refresh_token) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _yield$this$api$refre, data, error;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n\n                if (refresh_token) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new Error('No current session.');\n\n              case 3:\n                _context6.next = 5;\n                return this.api.refreshAccessToken(refresh_token);\n\n              case 5:\n                _yield$this$api$refre = _context6.sent;\n                data = _yield$this$api$refre.data;\n                error = _yield$this$api$refre.error;\n\n                if (!error) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", {\n                  session: null,\n                  error: error\n                });\n\n              case 10:\n                this._saveSession(data);\n\n                this._notifyAllSubscribers('SIGNED_IN');\n\n                return _context6.abrupt(\"return\", {\n                  session: data,\n                  error: null\n                });\n\n              case 15:\n                _context6.prev = 15;\n                _context6.t0 = _context6[\"catch\"](0);\n                return _context6.abrupt(\"return\", {\n                  error: _context6.t0,\n                  session: null\n                });\n\n              case 18:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 15]]);\n      }));\n    }\n    /**\n     * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n     * @param access_token a jwt access token\n     */\n\n  }, {\n    key: \"setAuth\",\n    value: function setAuth(access_token) {\n      this.currentSession = Object.assign(Object.assign({}, this.currentSession), {\n        access_token: access_token,\n        token_type: 'bearer',\n        user: null\n      });\n      return this.currentSession;\n    }\n    /**\n     * Gets the session data from a URL string\n     * @param options.storeSession Optionally store the session in the browser\n     */\n\n  }, {\n    key: \"getSessionFromUrl\",\n    value: function getSessionFromUrl(options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var error_description, provider_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$api$getUs, user, error, session, recoveryMode;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n\n                if (isBrowser()) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                throw new Error('No browser detected.');\n\n              case 3:\n                error_description = getParameterByName('error_description');\n\n                if (!error_description) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                throw new Error(error_description);\n\n              case 6:\n                provider_token = getParameterByName('provider_token');\n                access_token = getParameterByName('access_token');\n\n                if (access_token) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                throw new Error('No access_token detected.');\n\n              case 10:\n                expires_in = getParameterByName('expires_in');\n\n                if (expires_in) {\n                  _context7.next = 13;\n                  break;\n                }\n\n                throw new Error('No expires_in detected.');\n\n              case 13:\n                refresh_token = getParameterByName('refresh_token');\n\n                if (refresh_token) {\n                  _context7.next = 16;\n                  break;\n                }\n\n                throw new Error('No refresh_token detected.');\n\n              case 16:\n                token_type = getParameterByName('token_type');\n\n                if (token_type) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                throw new Error('No token_type detected.');\n\n              case 19:\n                timeNow = Math.round(Date.now() / 1000);\n                expires_at = timeNow + parseInt(expires_in);\n                _context7.next = 23;\n                return this.api.getUser(access_token);\n\n              case 23:\n                _yield$this$api$getUs = _context7.sent;\n                user = _yield$this$api$getUs.user;\n                error = _yield$this$api$getUs.error;\n\n                if (!error) {\n                  _context7.next = 28;\n                  break;\n                }\n\n                throw error;\n\n              case 28:\n                session = {\n                  provider_token: provider_token,\n                  access_token: access_token,\n                  expires_in: parseInt(expires_in),\n                  expires_at: expires_at,\n                  refresh_token: refresh_token,\n                  token_type: token_type,\n                  user: user\n                };\n\n                if (options === null || options === void 0 ? void 0 : options.storeSession) {\n                  this._saveSession(session);\n\n                  recoveryMode = getParameterByName('type');\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n\n                  if (recoveryMode === 'recovery') {\n                    this._notifyAllSubscribers('PASSWORD_RECOVERY');\n                  }\n                } // Remove tokens from URL\n\n\n                window.location.hash = '';\n                return _context7.abrupt(\"return\", {\n                  data: session,\n                  error: null\n                });\n\n              case 34:\n                _context7.prev = 34;\n                _context7.t0 = _context7[\"catch\"](0);\n                return _context7.abrupt(\"return\", {\n                  data: null,\n                  error: _context7.t0\n                });\n\n              case 37:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 34]]);\n      }));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n     *\n     * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n     */\n\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var accessToken, _yield$this$api$signO, error;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                accessToken = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.access_token;\n\n                this._removeSession();\n\n                this._notifyAllSubscribers('SIGNED_OUT');\n\n                if (!accessToken) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                _context8.next = 6;\n                return this.api.signOut(accessToken);\n\n              case 6:\n                _yield$this$api$signO = _context8.sent;\n                error = _yield$this$api$signO.error;\n\n                if (!error) {\n                  _context8.next = 10;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", {\n                  error: error\n                });\n\n              case 10:\n                return _context8.abrupt(\"return\", {\n                  error: null\n                });\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n     */\n\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this = this;\n\n      try {\n        var id = uuid();\n        var subscription = {\n          id: id,\n          callback: callback,\n          unsubscribe: function unsubscribe() {\n            _this.stateChangeEmitters.delete(id);\n          }\n        };\n        this.stateChangeEmitters.set(id, subscription);\n        return {\n          data: subscription,\n          error: null\n        };\n      } catch (e) {\n        return {\n          data: null,\n          error: e\n        };\n      }\n    }\n  }, {\n    key: \"_handleEmailSignIn\",\n    value: function _handleEmailSignIn(email, password) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _a, _b;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _yield$this$api$signI, data, error;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.prev = 0;\n                _context9.next = 3;\n                return this.api.signInWithEmail(email, password, {\n                  redirectTo: options.redirectTo\n                });\n\n              case 3:\n                _yield$this$api$signI = _context9.sent;\n                data = _yield$this$api$signI.data;\n                error = _yield$this$api$signI.error;\n\n                if (!(error || !data)) {\n                  _context9.next = 8;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: error\n                });\n\n              case 8:\n                if (((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.confirmed_at) || ((_b = data === null || data === void 0 ? void 0 : data.user) === null || _b === void 0 ? void 0 : _b.email_confirmed_at)) {\n                  this._saveSession(data);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                return _context9.abrupt(\"return\", {\n                  data: data,\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n\n              case 12:\n                _context9.prev = 12;\n                _context9.t0 = _context9[\"catch\"](0);\n                return _context9.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: _context9.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[0, 12]]);\n      }));\n    }\n  }, {\n    key: \"_handlePhoneSignIn\",\n    value: function _handlePhoneSignIn(phone, password) {\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var _yield$this$api$signI2, data, error;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.prev = 0;\n                _context10.next = 3;\n                return this.api.signInWithPhone(phone, password);\n\n              case 3:\n                _yield$this$api$signI2 = _context10.sent;\n                data = _yield$this$api$signI2.data;\n                error = _yield$this$api$signI2.error;\n\n                if (!(error || !data)) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: error\n                });\n\n              case 8:\n                if ((_a = data === null || data === void 0 ? void 0 : data.user) === null || _a === void 0 ? void 0 : _a.phone_confirmed_at) {\n                  this._saveSession(data);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n                return _context10.abrupt(\"return\", {\n                  data: data,\n                  user: data.user,\n                  session: data,\n                  error: null\n                });\n\n              case 12:\n                _context10.prev = 12;\n                _context10.t0 = _context10[\"catch\"](0);\n                return _context10.abrupt(\"return\", {\n                  data: null,\n                  user: null,\n                  session: null,\n                  error: _context10.t0\n                });\n\n              case 15:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[0, 12]]);\n      }));\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var url = this.api.getUrlForProvider(provider, {\n        redirectTo: options.redirectTo,\n        scopes: options.scopes\n      });\n\n      try {\n        // try to open on the browser\n        if (isBrowser()) {\n          window.location.href = url;\n        }\n\n        return {\n          provider: provider,\n          url: url,\n          data: null,\n          session: null,\n          user: null,\n          error: null\n        };\n      } catch (e) {\n        // fallback to returning the URL\n        if (url) return {\n          provider: provider,\n          url: url,\n          data: null,\n          session: null,\n          user: null,\n          error: null\n        };\n        return {\n          data: null,\n          user: null,\n          session: null,\n          error: e\n        };\n      }\n    }\n    /**\n     * Attempts to get the session from LocalStorage\n     * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n     */\n\n  }, {\n    key: \"_recoverSession\",\n    value: function _recoverSession() {\n      var _a;\n\n      try {\n        var json = isBrowser() && ((_a = this.localStorage) === null || _a === void 0 ? void 0 : _a.getItem(STORAGE_KEY));\n\n        if (!json || typeof json !== 'string') {\n          return null;\n        }\n\n        var data = JSON.parse(json);\n        var currentSession = data.currentSession,\n            expiresAt = data.expiresAt;\n        var timeNow = Math.round(Date.now() / 1000);\n\n        if (expiresAt >= timeNow && (currentSession === null || currentSession === void 0 ? void 0 : currentSession.user)) {\n          this._saveSession(currentSession);\n\n          this._notifyAllSubscribers('SIGNED_IN');\n        }\n      } catch (error) {\n        console.log('error', error);\n      }\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var json, data, currentSession, expiresAt, timeNow, _yield$this$_callRefr3, error;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.prev = 0;\n                _context11.t0 = isBrowser();\n\n                if (!_context11.t0) {\n                  _context11.next = 6;\n                  break;\n                }\n\n                _context11.next = 5;\n                return this.localStorage.getItem(STORAGE_KEY);\n\n              case 5:\n                _context11.t0 = _context11.sent;\n\n              case 6:\n                json = _context11.t0;\n\n                if (json) {\n                  _context11.next = 9;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", null);\n\n              case 9:\n                data = JSON.parse(json);\n                currentSession = data.currentSession, expiresAt = data.expiresAt;\n                timeNow = Math.round(Date.now() / 1000);\n\n                if (!(expiresAt < timeNow)) {\n                  _context11.next = 27;\n                  break;\n                }\n\n                if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                  _context11.next = 24;\n                  break;\n                }\n\n                _context11.next = 16;\n                return this._callRefreshToken(currentSession.refresh_token);\n\n              case 16:\n                _yield$this$_callRefr3 = _context11.sent;\n                error = _yield$this$_callRefr3.error;\n\n                if (!error) {\n                  _context11.next = 22;\n                  break;\n                }\n\n                console.log(error.message);\n                _context11.next = 22;\n                return this._removeSession();\n\n              case 22:\n                _context11.next = 25;\n                break;\n\n              case 24:\n                this._removeSession();\n\n              case 25:\n                _context11.next = 28;\n                break;\n\n              case 27:\n                if (!currentSession || !currentSession.user) {\n                  console.log('Current session is missing data.');\n\n                  this._removeSession();\n                } else {\n                  // should be handled on _recoverSession method already\n                  // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n                  this._saveSession(currentSession);\n\n                  this._notifyAllSubscribers('SIGNED_IN');\n                }\n\n              case 28:\n                _context11.next = 34;\n                break;\n\n              case 30:\n                _context11.prev = 30;\n                _context11.t1 = _context11[\"catch\"](0);\n                console.error(_context11.t1);\n                return _context11.abrupt(\"return\", null);\n\n              case 34:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[0, 30]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refresh_token) {\n      var _a;\n\n      if (refresh_token === void 0) {\n        refresh_token = (_a = this.currentSession) === null || _a === void 0 ? void 0 : _a.refresh_token;\n      }\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var _yield$this$api$refre2, data, error;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n\n                if (refresh_token) {\n                  _context12.next = 3;\n                  break;\n                }\n\n                throw new Error('No current session.');\n\n              case 3:\n                _context12.next = 5;\n                return this.api.refreshAccessToken(refresh_token);\n\n              case 5:\n                _yield$this$api$refre2 = _context12.sent;\n                data = _yield$this$api$refre2.data;\n                error = _yield$this$api$refre2.error;\n\n                if (!error) {\n                  _context12.next = 10;\n                  break;\n                }\n\n                throw error;\n\n              case 10:\n                if (data) {\n                  _context12.next = 12;\n                  break;\n                }\n\n                throw Error('Invalid session data.');\n\n              case 12:\n                this._saveSession(data);\n\n                this._notifyAllSubscribers('TOKEN_REFRESHED');\n\n                this._notifyAllSubscribers('SIGNED_IN');\n\n                return _context12.abrupt(\"return\", {\n                  data: data,\n                  error: null\n                });\n\n              case 18:\n                _context12.prev = 18;\n                _context12.t0 = _context12[\"catch\"](0);\n                return _context12.abrupt(\"return\", {\n                  data: null,\n                  error: _context12.t0\n                });\n\n              case 21:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 18]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event) {\n      var _this2 = this;\n\n      this.stateChangeEmitters.forEach(function (x) {\n        return x.callback(event, _this2.currentSession);\n      });\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      this.currentSession = session;\n      this.currentUser = session.user;\n      var expiresAt = session.expires_at;\n\n      if (expiresAt) {\n        var timeNow = Math.round(Date.now() / 1000);\n        var expiresIn = expiresAt - timeNow;\n        var refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5;\n\n        this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000);\n      } // Do we need any extra check before persist session\n      // access_token or user ?\n\n\n      if (this.persistSession && session.expires_at) {\n        this._persistSession(this.currentSession);\n      }\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      var data = {\n        currentSession: currentSession,\n        expiresAt: currentSession.expires_at\n      };\n      isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data));\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                this.currentSession = null;\n                this.currentUser = null;\n                if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n                _context13.t0 = isBrowser();\n\n                if (!_context13.t0) {\n                  _context13.next = 7;\n                  break;\n                }\n\n                _context13.next = 7;\n                return this.localStorage.removeItem(STORAGE_KEY);\n\n              case 7:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n    /**\n     * Clear and re-create refresh token timer\n     * @param value time intervals in milliseconds\n     */\n\n  }, {\n    key: \"_startAutoRefreshToken\",\n    value: function _startAutoRefreshToken(value) {\n      var _this3 = this;\n\n      if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer);\n      if (value <= 0 || !this.autoRefreshToken) return;\n      this.refreshTokenTimer = setTimeout(function () {\n        return _this3._callRefreshToken();\n      }, value);\n      if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref();\n    }\n    /**\n     * Listens for changes to LocalStorage and updates the current session.\n     */\n\n  }, {\n    key: \"_listenForMultiTabEvents\",\n    value: function _listenForMultiTabEvents() {\n      var _this4 = this;\n\n      if (!this.multiTab || !isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n        // console.debug('Auth multi-tab support is disabled.')\n        return false;\n      }\n\n      try {\n        window === null || window === void 0 ? void 0 : window.addEventListener('storage', function (e) {\n          var _a;\n\n          if (e.key === STORAGE_KEY) {\n            var newSession = JSON.parse(String(e.newValue));\n\n            if ((_a = newSession === null || newSession === void 0 ? void 0 : newSession.currentSession) === null || _a === void 0 ? void 0 : _a.access_token) {\n              _this4._recoverAndRefresh();\n\n              _this4._notifyAllSubscribers('SIGNED_IN');\n            } else {\n              _this4._removeSession();\n\n              _this4._notifyAllSubscribers('SIGNED_OUT');\n            }\n          }\n        });\n      } catch (error) {\n        console.error('_listenForMultiTabEvents', error);\n      }\n    }\n  }]);\n\n  return GoTrueClient;\n}();\n\nexport { GoTrueClient as default };","map":{"version":3,"sources":["C:\\Users\\Dave\\WebstormProjects\\wappsite\\node_modules\\@supabase\\gotrue-js\\src\\GoTrueClient.ts"],"names":[],"mappings":"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","sourcesContent":["import GoTrueApi from './GoTrueApi'\nimport { isBrowser, getParameterByName, uuid } from './lib/helpers'\nimport { GOTRUE_URL, DEFAULT_HEADERS, STORAGE_KEY } from './lib/constants'\nimport { polyfillGlobalThis } from './lib/polyfills'\nimport { Fetch } from './lib/fetch'\n\nimport type {\n  ApiError,\n  Session,\n  User,\n  UserAttributes,\n  Provider,\n  Subscription,\n  AuthChangeEvent,\n  CookieOptions,\n  UserCredentials,\n  VerifyOTPParams,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  multiTab: true,\n  headers: DEFAULT_HEADERS,\n}\n\ntype AnyFunction = (...args: any[]) => any\ntype MaybePromisify<T> = T | Promise<T>\n\ntype PromisifyMethods<T> = {\n  [K in keyof T]: T[K] extends AnyFunction\n    ? (...args: Parameters<T[K]>) => MaybePromisify<ReturnType<T[K]>>\n    : T[K]\n}\n\ntype SupportedStorage = PromisifyMethods<Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>>\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue API methods.\n   * These can be used for example to get a user from a JWT in a server environment or reset a user's password.\n   */\n  api: GoTrueApi\n  /**\n   * The currently logged in user or null.\n   */\n  protected currentUser: User | null\n  /**\n   * The session object for the currently logged in user or null.\n   */\n  protected currentSession: Session | null\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected localStorage: SupportedStorage\n  protected multiTab: boolean\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected refreshTokenTimer?: ReturnType<typeof setTimeout>\n\n  /**\n   * Create a new client for use in the browser.\n   * @param options.url The URL of the GoTrue server.\n   * @param options.headers Any additional headers to send to the GoTrue server.\n   * @param options.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n   * @param options.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n   * @param options.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n   * @param options.localStorage Provide your own local storage implementation to use instead of the browser's local storage.\n   * @param options.multiTab Set to \"false\" if you want to disable multi-tab/window events.\n   * @param options.cookieOptions\n   * @param options.fetch A custom fetch implementation.\n   */\n  constructor(options: {\n    url?: string\n    headers?: { [key: string]: string }\n    detectSessionInUrl?: boolean\n    autoRefreshToken?: boolean\n    persistSession?: boolean\n    localStorage?: SupportedStorage\n    multiTab?: boolean\n    cookieOptions?: CookieOptions\n    fetch?: Fetch\n  }) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.currentUser = null\n    this.currentSession = null\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.multiTab = settings.multiTab\n    this.localStorage = settings.localStorage || globalThis.localStorage\n    this.api = new GoTrueApi({\n      url: settings.url,\n      headers: settings.headers,\n      cookieOptions: settings.cookieOptions,\n      fetch: settings.fetch,\n    })\n    this._recoverSession()\n    this._recoverAndRefresh()\n    this._listenForMultiTabEvents()\n\n    if (settings.detectSessionInUrl && isBrowser() && !!getParameterByName('access_token')) {\n      // Handle the OAuth redirect\n      this.getSessionFromUrl({ storeSession: true }).then(({ error }) => {\n        if (error) {\n          console.error('Error getting session from URL.', error)\n        }\n      })\n    }\n  }\n\n  /**\n   * Creates a new user.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param phone The user's phone number.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param data Optional user metadata.\n   */\n  async signUp(\n    { email, password, phone }: UserCredentials,\n    options: {\n      redirectTo?: string\n      data?: object\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } =\n        phone && password\n          ? await this.api.signUpWithPhone(phone!, password!, {\n              data: options.data,\n            })\n          : await this.api.signUpWithEmail(email!, password!, {\n              redirectTo: options.redirectTo,\n              data: options.data,\n            })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on sign up.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in an existing user, or login via a third-party provider.\n   * @type UserCredentials\n   * @param email The user's email address.\n   * @param password The user's password.\n   * @param refreshToken A valid refresh token that was returned on login.\n   * @param provider One of the providers supported by GoTrue.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param scopes A space-separated list of scopes granted to the OAuth application.\n   */\n  async signIn(\n    { email, phone, password, refreshToken, provider }: UserCredentials,\n    options: {\n      redirectTo?: string\n      scopes?: string\n    } = {}\n  ): Promise<{\n    session: Session | null\n    user: User | null\n    provider?: Provider\n    url?: string | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      if (email && !password) {\n        const { error } = await this.api.sendMagicLinkEmail(email, {\n          redirectTo: options.redirectTo,\n        })\n        return { user: null, session: null, error }\n      }\n      if (email && password) {\n        return this._handleEmailSignIn(email, password, {\n          redirectTo: options.redirectTo,\n        })\n      }\n      if (phone && !password) {\n        const { error } = await this.api.sendMobileOTP(phone)\n        return { user: null, session: null, error }\n      }\n      if (phone && password) {\n        return this._handlePhoneSignIn(phone, password)\n      }\n      if (refreshToken) {\n        // currentSession and currentUser will be updated to latest on _callRefreshToken using the passed refreshToken\n        const { error } = await this._callRefreshToken(refreshToken)\n        if (error) throw error\n\n        return {\n          user: this.currentUser,\n          session: this.currentSession,\n          error: null,\n        }\n      }\n      if (provider) {\n        return this._handleProviderSignIn(provider, {\n          redirectTo: options.redirectTo,\n          scopes: options.scopes,\n        })\n      }\n      throw new Error(`You must provide either an email, phone number or a third-party provider.`)\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   * @param phone The user's phone number.\n   * @param token The user's password.\n   * @param redirectTo A URL or mobile address to send the user to after they are confirmed.\n   */\n  async verifyOTP(\n    { phone, token }: VerifyOTPParams,\n    options: {\n      redirectTo?: string\n    } = {}\n  ): Promise<{\n    user: User | null\n    session: Session | null\n    error: ApiError | null\n  }> {\n    try {\n      this._removeSession()\n\n      const { data, error } = await this.api.verifyMobileOTP(phone, token, options)\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw 'An error occurred on token verification.'\n      }\n\n      let session: Session | null = null\n      let user: User | null = null\n\n      if ((data as Session).access_token) {\n        session = data as Session\n        user = session.user as User\n        this._saveSession(session)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      if ((data as User).id) {\n        user = data as User\n      }\n\n      return { user, session, error: null }\n    } catch (e) {\n      return { user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `user()` will return the user data, if there is a logged in user.\n   *\n   * For server-side management, you can get a user through `auth.api.getUserByCookie()`\n   */\n  user(): User | null {\n    return this.currentUser\n  }\n\n  /**\n   * Returns the session data, if there is an active session.\n   */\n  session(): Session | null {\n    return this.currentSession\n  }\n\n  /**\n   * Force refreshes the session including the user data in case it was updated in a different session.\n   */\n  async refreshSession(): Promise<{\n    data: Session | null\n    user: User | null\n    error: ApiError | null\n  }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      // currentSession and currentUser will be updated to latest on _callRefreshToken\n      const { error } = await this._callRefreshToken()\n      if (error) throw error\n\n      return { data: this.currentSession, user: this.currentUser, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Updates user data, if there is a logged in user.\n   */\n  async update(\n    attributes: UserAttributes\n  ): Promise<{ data: User | null; user: User | null; error: ApiError | null }> {\n    try {\n      if (!this.currentSession?.access_token) throw new Error('Not logged in.')\n\n      const { user, error } = await this.api.updateUser(\n        this.currentSession.access_token,\n        attributes\n      )\n      if (error) throw error\n      if (!user) throw Error('Invalid user data.')\n\n      const session = { ...this.currentSession, user }\n      this._saveSession(session)\n      this._notifyAllSubscribers('USER_UPDATED')\n\n      return { data: user, user, error: null }\n    } catch (e) {\n      return { data: null, user: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Sets the session data from refresh_token and returns current Session and Error\n   * @param refresh_token a JWT token\n   */\n  async setSession(\n    refresh_token: string\n  ): Promise<{ session: Session | null; error: ApiError | null }> {\n    try {\n      if (!refresh_token) {\n        throw new Error('No current session.')\n      }\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) {\n        return { session: null, error: error }\n      }\n\n      this._saveSession(data!)\n      this._notifyAllSubscribers('SIGNED_IN')\n      return { session: data, error: null }\n    } catch (e) {\n      return { error: e as ApiError, session: null }\n    }\n  }\n\n  /**\n   * Overrides the JWT on the current client. The JWT will then be sent in all subsequent network requests.\n   * @param access_token a jwt access token\n   */\n  setAuth(access_token: string): Session {\n    this.currentSession = {\n      ...this.currentSession,\n      access_token,\n      token_type: 'bearer',\n      user: null,\n    }\n\n    return this.currentSession\n  }\n\n  /**\n   * Gets the session data from a URL string\n   * @param options.storeSession Optionally store the session in the browser\n   */\n  async getSessionFromUrl(options?: {\n    storeSession?: boolean\n  }): Promise<{ data: Session | null; error: ApiError | null }> {\n    try {\n      if (!isBrowser()) throw new Error('No browser detected.')\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) throw new Error(error_description)\n\n      const provider_token = getParameterByName('provider_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new Error('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new Error('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new Error('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new Error('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { user, error } = await this.api.getUser(access_token)\n      if (error) throw error\n\n      const session: Session = {\n        provider_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user: user!,\n      }\n      if (options?.storeSession) {\n        this._saveSession(session)\n        const recoveryMode = getParameterByName('type')\n        this._notifyAllSubscribers('SIGNED_IN')\n        if (recoveryMode === 'recovery') {\n          this._notifyAllSubscribers('PASSWORD_RECOVERY')\n        }\n      }\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: session, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a \"SIGNED_OUT\" event.\n   *\n   * For server-side management, you can disable sessions by passing a JWT through to `auth.api.signOut(JWT: string)`\n   */\n  async signOut(): Promise<{ error: ApiError | null }> {\n    const accessToken = this.currentSession?.access_token\n    this._removeSession()\n    this._notifyAllSubscribers('SIGNED_OUT')\n    if (accessToken) {\n      const { error } = await this.api.signOut(accessToken)\n      if (error) return { error }\n    }\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @returns {Subscription} A subscription object which can be used to unsubscribe itself.\n   */\n  onAuthStateChange(callback: (event: AuthChangeEvent, session: Session | null) => void): {\n    data: Subscription | null\n    error: ApiError | null\n  } {\n    try {\n      const id: string = uuid()\n      const subscription: Subscription = {\n        id,\n        callback,\n        unsubscribe: () => {\n          this.stateChangeEmitters.delete(id)\n        },\n      }\n      this.stateChangeEmitters.set(id, subscription)\n      return { data: subscription, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private async _handleEmailSignIn(\n    email: string,\n    password: string,\n    options: {\n      redirectTo?: string\n    } = {}\n  ) {\n    try {\n      const { data, error } = await this.api.signInWithEmail(email, password, {\n        redirectTo: options.redirectTo,\n      })\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.confirmed_at || data?.user?.email_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private async _handlePhoneSignIn(phone: string, password: string) {\n    try {\n      const { data, error } = await this.api.signInWithPhone(phone, password)\n      if (error || !data) return { data: null, user: null, session: null, error }\n\n      if (data?.user?.phone_confirmed_at) {\n        this._saveSession(data)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n\n      return { data, user: data.user, session: data, error: null }\n    } catch (e) {\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  private _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n    } = {}\n  ) {\n    const url: string = this.api.getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n    })\n\n    try {\n      // try to open on the browser\n      if (isBrowser()) {\n        window.location.href = url\n      }\n      return { provider, url, data: null, session: null, user: null, error: null }\n    } catch (e) {\n      // fallback to returning the URL\n      if (url) return { provider, url, data: null, session: null, user: null, error: null }\n      return { data: null, user: null, session: null, error: e as ApiError }\n    }\n  }\n\n  /**\n   * Attempts to get the session from LocalStorage\n   * Note: this should never be async (even for React Native), as we need it to return immediately in the constructor.\n   */\n  private _recoverSession() {\n    try {\n      const json = isBrowser() && this.localStorage?.getItem(STORAGE_KEY)\n      if (!json || typeof json !== 'string') {\n        return null\n      }\n\n      const data = JSON.parse(json)\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt >= timeNow && currentSession?.user) {\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (error) {\n      console.log('error', error)\n    }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const json = isBrowser() && (await this.localStorage.getItem(STORAGE_KEY))\n      if (!json) {\n        return null\n      }\n\n      const data = JSON.parse(json)\n      const { currentSession, expiresAt } = data\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if (expiresAt < timeNow) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n          if (error) {\n            console.log(error.message)\n            await this._removeSession()\n          }\n        } else {\n          this._removeSession()\n        }\n      } else if (!currentSession || !currentSession.user) {\n        console.log('Current session is missing data.')\n        this._removeSession()\n      } else {\n        // should be handled on _recoverSession method already\n        // But we still need the code here to accommodate for AsyncStorage e.g. in React native\n        this._saveSession(currentSession)\n        this._notifyAllSubscribers('SIGNED_IN')\n      }\n    } catch (err) {\n      console.error(err)\n      return null\n    }\n  }\n\n  private async _callRefreshToken(refresh_token = this.currentSession?.refresh_token) {\n    try {\n      if (!refresh_token) {\n        throw new Error('No current session.')\n      }\n      const { data, error } = await this.api.refreshAccessToken(refresh_token)\n      if (error) throw error\n      if (!data) throw Error('Invalid session data.')\n\n      this._saveSession(data)\n      this._notifyAllSubscribers('TOKEN_REFRESHED')\n      this._notifyAllSubscribers('SIGNED_IN')\n\n      return { data, error: null }\n    } catch (e) {\n      return { data: null, error: e as ApiError }\n    }\n  }\n\n  private _notifyAllSubscribers(event: AuthChangeEvent) {\n    this.stateChangeEmitters.forEach((x) => x.callback(event, this.currentSession))\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private _saveSession(session: Session) {\n    this.currentSession = session\n    this.currentUser = session.user\n\n    const expiresAt = session.expires_at\n    if (expiresAt) {\n      const timeNow = Math.round(Date.now() / 1000)\n      const expiresIn = expiresAt - timeNow\n      const refreshDurationBeforeExpires = expiresIn > 60 ? 60 : 0.5\n      this._startAutoRefreshToken((expiresIn - refreshDurationBeforeExpires) * 1000)\n    }\n\n    // Do we need any extra check before persist session\n    // access_token or user ?\n    if (this.persistSession && session.expires_at) {\n      this._persistSession(this.currentSession)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    const data = { currentSession, expiresAt: currentSession.expires_at }\n    isBrowser() && this.localStorage.setItem(STORAGE_KEY, JSON.stringify(data))\n  }\n\n  private async _removeSession() {\n    this.currentSession = null\n    this.currentUser = null\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    isBrowser() && (await this.localStorage.removeItem(STORAGE_KEY))\n  }\n\n  /**\n   * Clear and re-create refresh token timer\n   * @param value time intervals in milliseconds\n   */\n  private _startAutoRefreshToken(value: number) {\n    if (this.refreshTokenTimer) clearTimeout(this.refreshTokenTimer)\n    if (value <= 0 || !this.autoRefreshToken) return\n\n    this.refreshTokenTimer = setTimeout(() => this._callRefreshToken(), value)\n    if (typeof this.refreshTokenTimer.unref === 'function') this.refreshTokenTimer.unref()\n  }\n\n  /**\n   * Listens for changes to LocalStorage and updates the current session.\n   */\n  private _listenForMultiTabEvents() {\n    if (!this.multiTab || !isBrowser() || !window?.addEventListener) {\n      // console.debug('Auth multi-tab support is disabled.')\n      return false\n    }\n\n    try {\n      window?.addEventListener('storage', (e: StorageEvent) => {\n        if (e.key === STORAGE_KEY) {\n          const newSession = JSON.parse(String(e.newValue))\n          if (newSession?.currentSession?.access_token) {\n            this._recoverAndRefresh()\n            this._notifyAllSubscribers('SIGNED_IN')\n          } else {\n            this._removeSession()\n            this._notifyAllSubscribers('SIGNED_OUT')\n          }\n        }\n      })\n    } catch (error) {\n      console.error('_listenForMultiTabEvents', error)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}