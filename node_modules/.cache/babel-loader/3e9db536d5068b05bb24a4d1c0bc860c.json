{"ast":null,"code":"import _classCallCheck from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _inherits from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"C:\\\\Users\\\\Dave\\\\WebstormProjects\\\\wappsite\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport { PostgrestBuilder } from './types';\n/**\n * Post-filters (transforms)\n */\n\nvar PostgrestTransformBuilder = /*#__PURE__*/function (_PostgrestBuilder) {\n  _inherits(PostgrestTransformBuilder, _PostgrestBuilder);\n\n  var _super = _createSuper(PostgrestTransformBuilder);\n\n  function PostgrestTransformBuilder() {\n    _classCallCheck(this, PostgrestTransformBuilder);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PostgrestTransformBuilder, [{\n    key: \"select\",\n    value:\n    /**\n     * Performs vertical filtering with SELECT.\n     *\n     * @param columns  The columns to retrieve, separated by commas.\n     */\n    function select() {\n      var columns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '*';\n      // Remove whitespaces except when quoted\n      var quoted = false;\n      var cleanedColumns = columns.split('').map(function (c) {\n        if (/\\s/.test(c) && !quoted) {\n          return '';\n        }\n\n        if (c === '\"') {\n          quoted = !quoted;\n        }\n\n        return c;\n      }).join('');\n      this.url.searchParams.set('select', cleanedColumns);\n      return this;\n    }\n    /**\n     * Orders the result with the specified `column`.\n     *\n     * @param column  The column to order on.\n     * @param ascending  If `true`, the result will be in ascending order.\n     * @param nullsFirst  If `true`, `null`s appear first.\n     * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n     */\n\n  }, {\n    key: \"order\",\n    value: function order(column) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$ascending = _ref.ascending,\n          ascending = _ref$ascending === void 0 ? true : _ref$ascending,\n          _ref$nullsFirst = _ref.nullsFirst,\n          nullsFirst = _ref$nullsFirst === void 0 ? false : _ref$nullsFirst,\n          foreignTable = _ref.foreignTable;\n\n      var key = typeof foreignTable === 'undefined' ? 'order' : \"\".concat(foreignTable, \".order\");\n      var existingOrder = this.url.searchParams.get(key);\n      this.url.searchParams.set(key, \"\".concat(existingOrder ? \"\".concat(existingOrder, \",\") : '').concat(column, \".\").concat(ascending ? 'asc' : 'desc', \".\").concat(nullsFirst ? 'nullsfirst' : 'nullslast'));\n      return this;\n    }\n    /**\n     * Limits the result with the specified `count`.\n     *\n     * @param count  The maximum no. of rows to limit to.\n     * @param foreignTable  The foreign table to use (for foreign columns).\n     */\n\n  }, {\n    key: \"limit\",\n    value: function limit(count) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          foreignTable = _ref2.foreignTable;\n\n      var key = typeof foreignTable === 'undefined' ? 'limit' : \"\".concat(foreignTable, \".limit\");\n      this.url.searchParams.set(key, \"\".concat(count));\n      return this;\n    }\n    /**\n     * Limits the result to rows within the specified range, inclusive.\n     *\n     * @param from  The starting index from which to limit the result, inclusive.\n     * @param to  The last index to which to limit the result, inclusive.\n     * @param foreignTable  The foreign table to use (for foreign columns).\n     */\n\n  }, {\n    key: \"range\",\n    value: function range(from, to) {\n      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          foreignTable = _ref3.foreignTable;\n\n      var keyOffset = typeof foreignTable === 'undefined' ? 'offset' : \"\".concat(foreignTable, \".offset\");\n      var keyLimit = typeof foreignTable === 'undefined' ? 'limit' : \"\".concat(foreignTable, \".limit\");\n      this.url.searchParams.set(keyOffset, \"\".concat(from)); // Range is inclusive, so add 1\n\n      this.url.searchParams.set(keyLimit, \"\".concat(to - from + 1));\n      return this;\n    }\n    /**\n     * Sets the AbortSignal for the fetch request.\n     */\n\n  }, {\n    key: \"abortSignal\",\n    value: function abortSignal(signal) {\n      this.signal = signal;\n      return this;\n    }\n    /**\n     * Retrieves only one row from the result. Result must be one row (e.g. using\n     * `limit`), otherwise this will result in an error.\n     */\n\n  }, {\n    key: \"single\",\n    value: function single() {\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n      return this;\n    }\n    /**\n     * Retrieves at most one row from the result. Result must be at most one row\n     * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\n     * error.\n     */\n\n  }, {\n    key: \"maybeSingle\",\n    value: function maybeSingle() {\n      var _this2 = this;\n\n      this.headers['Accept'] = 'application/vnd.pgrst.object+json';\n\n      var _this = new PostgrestTransformBuilder(this);\n\n      _this.then = function (onfulfilled, onrejected) {\n        return _this2.then(function (res) {\n          var _a, _b;\n\n          if ((_b = (_a = res.error) === null || _a === void 0 ? void 0 : _a.details) === null || _b === void 0 ? void 0 : _b.includes('Results contain 0 rows')) {\n            return onfulfilled({\n              error: null,\n              data: null,\n              count: res.count,\n              status: 200,\n              statusText: 'OK',\n              body: null\n            });\n          }\n\n          return onfulfilled(res);\n        }, onrejected);\n      };\n\n      return _this;\n    }\n    /**\n     * Set the response type to CSV.\n     */\n\n  }, {\n    key: \"csv\",\n    value: function csv() {\n      this.headers['Accept'] = 'text/csv';\n      return this;\n    }\n  }]);\n\n  return PostgrestTransformBuilder;\n}(PostgrestBuilder);\n\nexport { PostgrestTransformBuilder as default };","map":{"version":3,"sources":["C:\\Users\\Dave\\WebstormProjects\\wappsite\\node_modules\\@supabase\\postgrest-js\\src\\lib\\PostgrestTransformBuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { PostgrestBuilder, PostgrestMaybeSingleResponse, PostgrestSingleResponse } from './types'\n\n/**\n * Post-filters (transforms)\n */\n\nexport default class PostgrestTransformBuilder<T> extends PostgrestBuilder<T> {\n  /**\n   * Performs vertical filtering with SELECT.\n   *\n   * @param columns  The columns to retrieve, separated by commas.\n   */\n  select(columns = '*'): this {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = columns\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    return this\n  }\n\n  /**\n   * Orders the result with the specified `column`.\n   *\n   * @param column  The column to order on.\n   * @param ascending  If `true`, the result will be in ascending order.\n   * @param nullsFirst  If `true`, `null`s appear first.\n   * @param foreignTable  The foreign table to use (if `column` is a foreign column).\n   */\n  order(\n    column: keyof T,\n    {\n      ascending = true,\n      nullsFirst = false,\n      foreignTable,\n    }: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string } = {}\n  ): this {\n    const key = typeof foreignTable === 'undefined' ? 'order' : `${foreignTable}.order`\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}.${\n        nullsFirst ? 'nullsfirst' : 'nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limits the result with the specified `count`.\n   *\n   * @param count  The maximum no. of rows to limit to.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n  limit(count: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const key = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limits the result to rows within the specified range, inclusive.\n   *\n   * @param from  The starting index from which to limit the result, inclusive.\n   * @param to  The last index to which to limit the result, inclusive.\n   * @param foreignTable  The foreign table to use (for foreign columns).\n   */\n  range(from: number, to: number, { foreignTable }: { foreignTable?: string } = {}): this {\n    const keyOffset = typeof foreignTable === 'undefined' ? 'offset' : `${foreignTable}.offset`\n    const keyLimit = typeof foreignTable === 'undefined' ? 'limit' : `${foreignTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Sets the AbortSignal for the fetch request.\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Retrieves only one row from the result. Result must be one row (e.g. using\n   * `limit`), otherwise this will result in an error.\n   */\n  single(): PromiseLike<PostgrestSingleResponse<T>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    return this as PromiseLike<PostgrestSingleResponse<T>>\n  }\n\n  /**\n   * Retrieves at most one row from the result. Result must be at most one row\n   * (e.g. using `eq` on a UNIQUE column), otherwise this will result in an\n   * error.\n   */\n  maybeSingle(): PromiseLike<PostgrestMaybeSingleResponse<T>> {\n    this.headers['Accept'] = 'application/vnd.pgrst.object+json'\n    const _this = new PostgrestTransformBuilder(this)\n    _this.then = ((onfulfilled: any, onrejected: any) =>\n      this.then((res: any): any => {\n        if (res.error?.details?.includes('Results contain 0 rows')) {\n          return onfulfilled({\n            error: null,\n            data: null,\n            count: res.count,\n            status: 200,\n            statusText: 'OK',\n            body: null,\n          })\n        }\n\n        return onfulfilled(res)\n      }, onrejected)) as any\n    return _this as PromiseLike<PostgrestMaybeSingleResponse<T>>\n  }\n\n  /**\n   * Set the response type to CSV.\n   */\n  csv(): PromiseLike<PostgrestSingleResponse<string>> {\n    this.headers['Accept'] = 'text/csv'\n    return this as PromiseLike<PostgrestSingleResponse<string>>\n  }\n}\n"]},"metadata":{},"sourceType":"module"}